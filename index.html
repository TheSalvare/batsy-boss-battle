<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoRose - Batsy Boss Battle</title>
    <script src="https://cdn.jsdelivr.net/npm/tmi.js@1.8.5/dist/tmi.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #1a1520;
            --bg-medium: #2E2733;
            --lavender: #9A82A9;
            --rose: #F6AAB4;
            --cream: #FFF8FC;
            --health-green: #7BC96F;
            --health-red: #E85C5C;
            --gold: #FEE590;
            --player-attack: #FAE69B;
            --phase2-orange: #FF6B35;
            --shield-marker: url('images/hit_marker_shield.PNG');
        }

        body {
            font-family: 'VT323', monospace;
            background: var(--bg-dark);
            color: var(--cream);
            overflow: hidden;
            width: 1920px;
            height: 1080px;
        }

        .game-container {
            width: 1920px;
            height: 1080px;
            position: relative;
            overflow: hidden;
        }

        .cave-background {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-image: url('images/background.png');
            background-size: cover;
            background-position: center;
            z-index: 1;
        }

        .cave-background::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(26, 21, 32, 0.3);
            z-index: 2;
            transition: background 0.5s ease;
        }

        /* Phase 2 darker atmosphere */
        .game-container.phase2 .cave-background::after {
            background: rgba(26, 21, 32, 0.5);
        }
        .cave-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-image: url('images/background_overlay.png');
            background-size: cover;
            background-position: center;
            z-index: 35;
            pointer-events: none;
        }
        .cave-corner-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-image: url('images/background_overlay_corners.png');
            background-size: cover;
            background-position: center;
            z-index: 50;
            pointer-events: none;
        }


        /* Stream Windows - 15% larger */
        .stream-window {
            position: absolute;
            width: 389px;
            height: 219px;
            background: var(--bg-medium);
            border: 4px solid var(--lavender);
            border-radius: 8px;
            overflow: hidden;
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .stream-window.gameplay { top: 20px; left: 20px; }
        .stream-window.camera { top: 20px; right: 20px; }

        .stream-window-label {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            background: rgba(46, 39, 51, 0.95);
            padding: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            text-align: center;
            color: var(--rose);
            text-transform: uppercase;
        }

        .stream-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--lavender);
            font-size: 14px;
            text-align: center;
            background: repeating-linear-gradient(45deg, var(--bg-dark), var(--bg-dark) 10px, var(--bg-medium) 10px, var(--bg-medium) 20px);
        }

        /* Game Title */
        .game-title {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 28px;
            color: var(--rose);
            text-shadow: 3px 3px 0 var(--bg-medium), 5px 5px 0 var(--lavender);
            z-index: 50;
        }

        /* Boss Area */
        .boss-area {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 30;
        }

        .boss-health-container {
            width: 450px;
            margin-bottom: 10px;
        }

        .boss-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            color: var(--rose);
            margin-bottom: 5px;
            text-align: center;
            text-transform: uppercase;
            text-shadow: 2px 2px 0 var(--bg-dark);
            transition: color 0.3s ease;
        }

        .game-container.phase2 .boss-name {
            color: var(--phase2-orange);
        }

        .boss-health-bar {
            width: 100%;
            height: 28px;
            background: var(--bg-medium);
            border: 3px solid var(--lavender);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            transition: border-color 0.3s ease;
        }

        .game-container.phase2 .boss-health-bar {
            border-color: var(--phase2-orange);
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(180deg, var(--health-red) 0%, #c44 100%);
            transition: width 0.3s ease, background 0.3s ease;
            position: relative;
        }

        .game-container.phase2 .boss-health-fill {
            background: linear-gradient(180deg, var(--phase2-orange) 0%, #cc4420 100%);
        }

        .boss-health-fill::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3) 0%, transparent 100%);
        }

        .boss-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
            color: var(--cream);
            text-shadow: 1px 1px 0 var(--bg-dark);
            z-index: 5;
        }

        .boss-phase {
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: var(--gold);
            margin-top: 13px;
            text-align: center;
            text-shadow: 1px 1px 0 var(--bg-dark);
            transition: color 0.3s ease;
        }

        .game-container.phase2 .boss-phase {
            color: var(--phase2-orange);
            animation: phaseGlow 0.5s ease-in-out infinite alternate;
        }

        @keyframes phaseGlow {
            0% { text-shadow: 1px 1px 0 var(--bg-dark), 0 0 10px var(--phase2-orange); }
            100% { text-shadow: 1px 1px 0 var(--bg-dark), 0 0 20px var(--phase2-orange); }
        }

        /* Boss Sprite - Batsy */
        .boss-sprite-container {
            position: relative;
            width: 350px;
            height: 280px;
        }

        .boss-sprite {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .boss-image {
            width: 438px;
            height: auto;
            animation: bossIdle 1.5s ease-in-out infinite;
            filter: drop-shadow(0 8px 20px rgba(0,0,0,0.6));
            transition: filter 0.3s ease;
        }

        .game-container.phase2 .boss-image {
            filter: drop-shadow(0 8px 20px rgba(0,0,0,0.6)) drop-shadow(0 0 20px rgba(255, 107, 53, 0.5));
        }

        @keyframes bossIdle {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-8px) scale(1.02); }
        }

        /* Phase 1: Ground slam animation */
        .boss-sprite.slamming .boss-image {
            animation: bossSlam 0.5s ease;
        }

        @keyframes bossSlam {
            0% { transform: translateY(0) scale(1); }
            30% { transform: translateY(-20px) scale(1.05); }
            60% { transform: translateY(15px) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }

        /* Phase 2: Frenzy animation */
        .boss-sprite.frenzied .boss-image {
            animation: bossFrenzy 0.3s ease;
        }

        @keyframes bossFrenzy {
            0% { transform: translateX(0) scale(1.05); }
            25% { transform: translateX(-10px) scale(1.08); }
            50% { transform: translateX(10px) scale(1.08); }
            75% { transform: translateX(-5px) scale(1.05); }
            100% { transform: translateX(0) scale(1.05); }
        }

        .boss-sprite.damaged .boss-image {
            animation: bossDamaged 0.15s ease !important;
        }

        @keyframes bossDamaged {
            0%, 100% { filter: brightness(1) drop-shadow(0 5px 15px rgba(0,0,0,0.5)); }
            50% { filter: brightness(2.5) hue-rotate(30deg) drop-shadow(0 5px 20px rgba(255,255,255,0.5)); }
        }

        /* Boss Projectiles - using sprite images */
        .boss-projectile {
            position: absolute;
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 40;
            pointer-events: none;
            image-rendering: pixelated;
        }

        /* Boss Projectiles - Phase 2 */
        .boss-projectile.phase2 {
            width: 50px;
            height: 50px;
            filter: drop-shadow(0 0 8px rgba(255, 107, 53, 0.7));
        }

        /* Boss Projectiles - using sprite images */
        .rain-projectile {
            position: absolute;
            width: 70px;
            height: 70px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 40;
            pointer-events: none;
            image-rendering: pixelated;
        }

        /* Boss Projectiles - Phase 2 */
        .rain-projectile.phase2 {
            width: 80px;
            height: 80px;
            filter: drop-shadow(0 0 8px rgba(255, 107, 53, 0.7));
        }

        /* Player Projectiles - Arrow */
        .player-projectile {
            position: absolute;
            width: 14px;
            height: 22px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 25;
            pointer-events: none;
            image-rendering: pixelated;
            filter: drop-shadow(0 0 4px rgba(250, 230, 155, 0.6));
        }

        /* Impact Effects - Using custom hit markers */
        .impact {
            position: absolute;
            width: 50px;
            height: 50px;
            z-index: 41;
            pointer-events: none;
            background-image: url('images/hit_marker_damage.PNG');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated;
            animation: impactPop 0.4s ease-out forwards;
        }

        .impact.player-impact {
            width: 45px;
            height: 45px;
        }

        .impact.phase2 {
            width: 55px;
            height: 55px;
            filter: hue-rotate(-20deg) brightness(1.2);
        }
        
        .impact.death-marker {
            width: 60px;
            height: 60px;
            background-image: url('images/hit_marker_death.PNG');
            animation: impactPop 0.6s ease-out forwards;
        }

        @keyframes impactPop {
            0% { transform: scale(0.3); opacity: 1; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        /* Death Effect */
        .death-effect {
            position: absolute;
            width: 80px;
            height: 80px;
            z-index: 200;
            pointer-events: none;
        }

        .death-effect::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(232, 92, 92, 0.9) 0%, rgba(232, 92, 92, 0.3) 50%, transparent 70%);
            animation: deathFlash 0.6s ease-out forwards;
        }

        @keyframes deathFlash {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            30% { transform: translate(-50%, -50%) scale(2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }

        /* Particle burst on death */
        .death-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--health-red);
            border-radius: 50%;
            z-index: 199;
            pointer-events: none;
        }

        /* Screen shake for phase 2 */
        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-3px, -2px); }
            20% { transform: translate(3px, 2px); }
            30% { transform: translate(-2px, 3px); }
            40% { transform: translate(2px, -3px); }
            50% { transform: translate(-3px, 2px); }
            60% { transform: translate(3px, -2px); }
            70% { transform: translate(-2px, -3px); }
            80% { transform: translate(2px, 3px); }
            90% { transform: translate(-3px, -2px); }
        }

        .game-container.shaking {
            animation: screenShake 0.3s ease;
        }

        /* Player Area */
        .player-area {
            position: absolute;
            top: 380px;
            left: 80px;
            right: 80px;
            bottom: 160px;
            z-index: 20;
        }

        /* Knight Sprites */
        .player-sprite-container {
            position: absolute;
            width: 61px;
            height: 76px;
            z-index: 20;
        }

        .player-sprite-container.dead {
            opacity: 0.7;
        }
        
        .player-sprite-container.dead .knight-image {
            content: url('images/death_state.PNG');
        }
        
        .player-sprite-container.dead .player-arm-img {
            display: none;
        }
        
        /* Shielded state - semi-transparent and immune */
        .player-sprite-container.shielded {
            opacity: 0.5;
            filter: drop-shadow(0 0 10px rgba(150, 200, 255, 0.8));
        }
        
        .player-sprite-container.shielded::before {
            content: '';
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 25px;
            background-image: var(--shield-marker);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 30;
            pointer-events: none;
        }
        
        /* Speech bubble for taunts */
        .speech-bubble {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            color: #333;
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 16px;
            font-family: 'VT323', monospace;
            white-space: nowrap;
            z-index: 100;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: bubblePop 0.2s ease-out;
        }
        
        .speech-bubble::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: white;
        }
        
        @keyframes bubblePop {
            0% { transform: translateX(-50%) scale(0); }
            50% { transform: translateX(-50%) scale(1.1); }
            100% { transform: translateX(-50%) scale(1); }
        }

        .knight-image {
            width: 61px;
            height: 61px;
            image-rendering: pixelated;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.5));
        }

        .player-sprite-container.walking .knight-image {
            /* Animation handled by JavaScript frame switching */
        }

        .player-sprite-container.walking .player-arm-img {
            /* Animation handled by JavaScript frame switching */
        }

        .player-sprite-container.attacking .knight-image {
            animation: knightAttack 0.25s ease;
        }

        @keyframes knightAttack {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-10px) scale(1.15); }
        }

        .player-sprite-container.healing::before {
            content: '✨';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            animation: healSparkle 0.5s ease forwards;
            z-index: 30;
        }

        @keyframes healSparkle {
            0% { opacity: 0; transform: translateX(-50%) translateY(5px) scale(0.5); }
            50% { opacity: 1; transform: translateX(-50%) translateY(0) scale(1.2); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-15px) scale(0.8); }
        }

        .player-sprite-container.damaged .knight-image {
            animation: knightDamaged 0.25s ease;
        }

        @keyframes knightDamaged {
            0%, 100% { transform: translateX(0); filter: brightness(1) drop-shadow(2px 2px 2px rgba(0,0,0,0.5)); }
            25% { transform: translateX(-4px); filter: brightness(2) drop-shadow(2px 2px 2px rgba(0,0,0,0.5)); }
            75% { transform: translateX(4px); filter: brightness(2) drop-shadow(2px 2px 2px rgba(0,0,0,0.5)); }
        }

        .player-weapon {
            position: absolute;
            bottom: 20px;
            right: -5px;
            font-size: 14px;
            filter: drop-shadow(1px 1px 0 #000);
            z-index: 25;
        }

        .player-arm-img {
            position: absolute;
            top: 0;
            left: 0;
            width: 61px;
            height: 61px;
            image-rendering: pixelated;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.5));
            z-index: 19;
        }

        .player-info {
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 70px;
        }

        .player-name {
            font-size: 13px;
            color: var(--cream);
            text-shadow: 1px 1px 0 #000;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-health-bar {
            width: 58px;
            height: 7px;
            background: #1a1a2a;
            border: 1px solid #3a3a4a;
            border-radius: 2px;
            margin: 2px auto 0;
            overflow: hidden;
        }

        .player-health-fill {
            height: 100%;
            background: var(--health-green);
            transition: width 0.2s ease, background 0.2s ease;
        }

        .player-health-fill.medium { background: #FFC0A7; }
        .player-health-fill.low { background: #E2675D; }

        /* Floating Text */
        .floating-text {
            position: absolute;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            pointer-events: none;
            z-index: 200;
            animation: floatUp 0.8s ease forwards;
            text-shadow: 2px 2px 0 #000;
        }

        .floating-text.damage { color: var(--health-red); }
        .floating-text.heal { color: var(--health-green); }
        .floating-text.crit { font-size: 18px; color: var(--gold); }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-40px) scale(1.2); }
        }

        /* Status Bar */
        .status-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 32px;
            background: rgba(26, 21, 32, 0.92);
            padding: 14px 40px;
            border-radius: 10px;
            border: 4px solid var(--lavender);
            z-index: 50;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }

        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .status-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
            color: var(--lavender);
            text-transform: uppercase;
        }

        .status-value {
            font-family: 'Press Start 2P', cursive;
            font-size: 15px;
            color: var(--cream);
        }

        .status-value.timer { color: var(--gold); }
        .status-value.players { color: var(--rose); }

        /* Command Hints */
        .command-hints {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 16px;
            z-index: 40;
        }

        .command-hint {
            background: rgba(26, 21, 32, 0.92);
            padding: 10px 20px;
            border-radius: 6px;
            border: 3px solid var(--lavender);
            font-family: 'VT323', monospace;
            font-size: 21px;
            color: var(--cream);
        }

        .command-hint .cmd { color: var(--rose); font-weight: bold; }

        /* Battle Log - Larger, bottom right */
        .battle-log {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 220px;
            background: rgba(26, 21, 32, 0.92);
            border: 3px solid var(--lavender);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            z-index: 55;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }

        .battle-log-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            color: var(--rose);
            margin-bottom: 12px;
            text-transform: uppercase;
        }

        .battle-log-entry {
            font-size: 16px;
            color: var(--cream);
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(154, 130, 169, 0.2);
        }

        .battle-log::-webkit-scrollbar { width: 6px; }
        .battle-log::-webkit-scrollbar-track { background: var(--bg-dark); }
        .battle-log::-webkit-scrollbar-thumb { background: var(--lavender); border-radius: 3px; }

        /* Phase Overlays */
        .phase-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(26, 21, 32, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
        }

        .phase-overlay.active { opacity: 1; visibility: visible; }

        .phase-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 57px;
            color: var(--rose);
            text-shadow: 6px 6px 0 var(--lavender);
            margin-bottom: 30px;
            text-align: center;
        }

        .phase-subtitle {
            font-family: 'VT323', monospace;
            font-size: 39px;
            color: var(--cream);
            margin-bottom: 18px;
        }

        .phase-timer {
            font-family: 'Press Start 2P', cursive;
            font-size: 84px;
            color: var(--gold);
            text-shadow: 5px 5px 0 var(--bg-medium);
        }

        .phase-instruction {
            font-family: 'VT323', monospace;
            font-size: 33px;
            color: var(--lavender);
            margin-top: 30px;
        }

        .player-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            max-width: 900px;
            margin-top: 27px;
        }

        .player-list-item {
            background: var(--bg-medium);
            padding: 8px 18px;
            border-radius: 8px;
            border: 3px solid var(--rose);
            font-size: 21px;
            color: var(--cream);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Phase 2 Transition Overlay */
        .phase-transition-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 107, 53, 0);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 450;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease, background 0.3s ease;
        }

        .phase-transition-overlay.active {
            opacity: 1;
            visibility: visible;
            background: rgba(255, 107, 53, 0.3);
            animation: phase2Flash 1s ease;
        }

        @keyframes phase2Flash {
            0% { background: rgba(255, 107, 53, 0); }
            30% { background: rgba(255, 107, 53, 0.6); }
            100% { background: rgba(255, 107, 53, 0.1); }
        }

        .phase-transition-overlay .phase-title {
            color: var(--phase2-orange);
            text-shadow: 6px 6px 0 var(--bg-dark), 0 0 45px var(--phase2-orange);
            animation: phase2TextPulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes phase2TextPulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        /* Result Screens */
        .result-screen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 600;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
        }

        .result-screen.active { opacity: 1; visibility: visible; }
        .result-screen.victory { background: linear-gradient(180deg, rgba(162, 207, 168, 0.85) 0%, rgba(26, 21, 32, 0.95) 100%); }
        .result-screen.defeat { background: linear-gradient(180deg, rgba(232, 92, 92, 0.85) 0%, rgba(26, 21, 32, 0.95) 100%); }

        .result-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 60px;
            margin-bottom: 36px;
            text-shadow: 6px 6px 0 var(--bg-dark);
        }

        .result-screen.victory .result-title { color: var(--gold); }
        .result-screen.defeat .result-title { color: var(--health-red); }

        .mvp-section {
            background: rgba(46, 39, 51, 0.92);
            padding: 26px 54px;
            border-radius: 14px;
            border: 5px solid var(--gold);
            text-align: center;
        }

        .mvp-label { font-family: 'Press Start 2P', cursive; font-size: 14px; color: var(--gold); margin-bottom: 12px; }
        .mvp-name { font-family: 'Press Start 2P', cursive; font-size: 29px; color: var(--cream); margin-bottom: 18px; }
        .mvp-stats { display: flex; gap: 36px; justify-content: center; }
        .mvp-stat { text-align: center; }
        .mvp-stat-label { font-size: 14px; color: var(--lavender); margin-bottom: 4px; }
        .mvp-stat-value { font-family: 'Press Start 2P', cursive; font-size: 22px; color: var(--cream); }

        .stats-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            margin-top: 36px;
            max-width: 1000px;
        }

        .stat-card {
            background: rgba(46, 39, 51, 0.8);
            padding: 12px;
            border-radius: 6px;
            border: 2px solid var(--lavender);
            text-align: center;
            width: 180px;
            flex-shrink: 0;
        }

        .stat-card-name { font-size: 14px; color: var(--rose); margin-bottom: 6px; }
        .stat-card-damage { font-family: 'Press Start 2P', cursive; font-size: 12px; color: var(--health-red); }
        .stat-card-healing { font-family: 'Press Start 2P', cursive; font-size: 12px; color: var(--health-green); }
    </style>
</head>
<body>
    <div class="game-container" id="game">
        <div class="cave-background"></div>
        <div class="cave-overlay"></div>
        <div class="cave-corner-overlay"></div>

        <div class="game-title">BOSS BATTLE</div>

        <div class="boss-area" id="boss-area">
            <div class="boss-health-container">
                <div class="boss-name" id="boss-name">BATSY THE BEAST</div>
                <div class="boss-health-bar">
                    <div class="boss-health-fill" id="boss-health-fill" style="width: 100%;"></div>
                    <div class="boss-health-text" id="boss-health-text">500 / 500</div>
                </div>
                <div class="boss-phase" id="boss-phase">GROUND SLAM</div>
            </div>
            <div class="boss-sprite-container">
                <div class="boss-sprite" id="boss-sprite">
                    <img class="boss-image" id="boss-image" src="images/batsy_static.PNG">
                </div>
            </div>
        </div>

        <div id="projectiles-container" style="position:absolute;top:0;left:0;right:0;bottom:0;z-index:40;pointer-events:none;"></div>

        <div class="player-area" id="player-area"></div>

        <div id="floating-text-container" style="position:absolute;top:0;left:0;right:0;bottom:0;z-index:200;pointer-events:none;"></div>

        <div class="command-hints" id="command-hints" style="display:none;">
            <div class="command-hint"><span class="cmd">!attack</span> - Deal damage</div>
            <div class="command-hint"><span class="cmd">!heal</span> - Heal yourself</div>
            <div class="command-hint"><span class="cmd">!shield</span> - Block damage</div>
        </div>

        <div class="battle-log" id="battle-log">
            <div class="battle-log-title">Battle Log</div>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <span class="status-label">Players</span>
                <span class="status-value players" id="player-count">0 / 30</span>
            </div>
            <div class="status-item">
                <span class="status-label">Alive</span>
                <span class="status-value" id="alive-count">0</span>
            </div>
            <div class="status-item">
                <span class="status-label">Time</span>
                <span class="status-value timer" id="game-timer">0:00</span>
            </div>
            <div class="status-item">
                <span class="status-label">Total DMG</span>
                <span class="status-value" id="total-damage">0</span>
            </div>
        </div>

        <!-- Phase Overlays -->
        <div class="phase-overlay active" id="lobby-overlay">
            <div class="phase-title">BOSS BATTLE</div>
            <div class="phase-subtitle">Type <span style="color: var(--rose);">!play</span> in chat to join!</div>
            <div class="phase-timer" id="lobby-timer">60</div>
            <div class="phase-instruction">Waiting for players... (Max 25)</div>
            <div class="player-list" id="lobby-player-list"></div>
        </div>

        <div class="phase-overlay" id="boss-intro-overlay">
            <div class="phase-title" id="boss-intro-name">BATSY THE BEAST</div>
            <div class="phase-subtitle">has awoken!</div>
            <div style="background: rgba(46, 39, 51, 0.9); padding: 25px 40px; border-radius: 12px; border: 3px solid var(--lavender); max-width: 800px; text-align: left; margin-top: 20px;">
                <div style="font-size: 22px; color: var(--cream); line-height: 1.7; margin-bottom: 15px;">
                    Work together to kill Batsy the Beast. The player to collectively earn the most points through attacking and healing will be crowned winner.
                </div>
                <div style="font-size: 20px; color: var(--cream); line-height: 1.8;">
                    <div style="margin-bottom: 10px;"><span style="color: var(--rose);">!attack</span> — Cause damage to Batsy</div>
                    <div style="margin-bottom: 10px;"><span style="color: var(--rose);">!heal</span> — Heal yourself, or tag another player to heal them instead</div>
                    <div style="margin-bottom: 10px;"><span style="color: var(--rose);">!shield</span> — Block all damage for 5 seconds (you cannot attack or heal during this period)</div>
                    <div style="margin-bottom: 10px;"><span style="color: var(--rose);">!taunt 'message'</span> — Feeling brave? Taunt Batsy to increase your next attack by 50%! (18 char limit)</div>
                    <div style="margin-top: 15px; font-size: 18px; color: var(--lavender); text-align: center;">All commands have cooldowns, so no need to spam.</div>
                </div>
            </div>
            <div class="phase-timer" id="intro-timer" style="margin-top: 25px;">20</div>
            <div style="font-size: 20px; color: var(--lavender); margin-top: 5px;">Battle begins in...</div>
        </div>

        <!-- Phase 2 Transition -->
        <div class="phase-transition-overlay" id="phase2-overlay">
            <div class="phase-title">PHASE 2</div>
            <div class="phase-subtitle" style="color: var(--phase2-orange);">BATSY IS ENRAGED!</div>
        </div>

        <!-- Result Screens -->
        <div class="result-screen victory" id="victory-screen">
            <div class="result-title">VICTORY!</div>
            <div class="mvp-section">
                <div class="mvp-label">★ CHAMPION BATSY SLAYER ★</div>
                <div class="mvp-name" id="mvp-name">PlayerName</div>
                <div class="mvp-stats">
                    <div class="mvp-stat">
                        <div class="mvp-stat-label">Damage</div>
                        <div class="mvp-stat-value" id="mvp-damage">0</div>
                    </div>
                    <div class="mvp-stat">
                        <div class="mvp-stat-label">Healing</div>
                        <div class="mvp-stat-value" id="mvp-healing">0</div>
                    </div>
                </div>
            </div>
            <div class="stats-grid" id="victory-stats"></div>
        </div>

        <div class="result-screen defeat" id="defeat-screen">
            <div class="result-title">DEFEAT</div>
            <div class="phase-subtitle" style="margin-bottom: 15px;">Batsy remains victorious...</div>
            <div class="mvp-section" style="border-color: var(--lavender);">
                <div class="mvp-label" style="color: var(--lavender);">BEST EFFORT</div>
                <div class="mvp-name" id="defeat-mvp-name">PlayerName</div>
                <div class="mvp-stats">
                    <div class="mvp-stat">
                        <div class="mvp-stat-label">Boss HP Left</div>
                        <div class="mvp-stat-value" id="defeat-boss-hp">0</div>
                    </div>
                    <div class="mvp-stat">
                        <div class="mvp-stat-label">Team Damage</div>
                        <div class="mvp-stat-value" id="defeat-team-damage">0</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>

                // Knight animation frames (5 frames)
        const KNIGHT_FRAMES = {
            1: 'images/knight_run_1.PNG',
            2: 'images/knight_run_2.PNG',
            3: 'images/knight_run_3.PNG',
            4: 'images/knight_run_4.PNG',
            5: 'images/knight_run_5.PNG'
        };

                // ===== BATSY ANIMATION FRAMES =====
        const BATSY_FRAMES = {
            'static': 'images/batsy_static.PNG',
            'preslam': 'images/batsy_preslam.PNG',
            'slam': 'images/batsy_slam.PNG'
        };
        
        // Projectile images per weapon
        const PROJECTILE_IMAGES = {
            bow: 'images/player_arrow_bow.PNG',
            bossLarge: 'images/projectile_large.PNG',
            bossSmall: 'images/projectile_small.PNG',
        };

        // Falling projectile images
        const FALL_PROJECTILE_IMAGES = {
            rockSlideSmall: 'images/projectile_rain_small.PNG',
            rockSlideLarge: 'images/projectile_rain_large.PNG'
        };
        
        // Hit marker images
        const HIT_MARKERS = {
            damage: 'images/hit_marker_damage.PNG',
            death: 'images/hit_marker_death.PNG',
            shield: 'images/hit_marker_shield.PNG'
        };
        
        // Death state image  
        const DEATH_STATE_IMG = 'images/death_state.PNG'

        // ===== GAME CONFIGURATION =====
        const CONFIG = {
            channel: 'geor0se',
            maxPlayers: 25,
            lobbyDuration: 60,
            bossIntroDuration: 30,
            
            // Phase 1 Boss - Slower attacks, more projectiles per attack
            phase1Health: 500,
            phase1AttackInterval: 3000,
            phase1HitChance: 0.5,
            phase1ProjectilesMin: 5,
            phase1ProjectilesMax: 9,
            
            // Phase 2 Boss
            phase2Health: 250,
            phase2AttackInterval: 400,
            phase2HitChance: 0.65,
            phase2ProjectilesMin: 3,
            phase2ProjectilesMax: 6,
            
            bossBaseDamage: 12,
            
            playerMaxHealth: 100,
            attackCooldown: 3000,
            healCooldown: 5000,
            healAmount: 10,
            
            maxDamageMultiplier: 1.5,
            minDamageMultiplier: 0.7,
            
            playerMoveSpeed: 3.6,
            playerMoveInterval: 50,
            playAreaWidth: 1760,
            playAreaHeight: 540,
            playerAreaTop: 380,
            
            playerHitboxWidth: 51,
            playerHitboxHeight: 61,
            phase1ProjectileSize: 24,
            phase2ProjectileSize: 32,
            
            // Bow weapon stats
            bowDamage: 10,
            bowCritChance: 0.15,
            
            // Restricted zones (areas players cannot enter) - in SCREEN coordinates
            // Triangular corner zones approximated with stacked rectangles
            restrictedZones: [
                // Zone 1: Right side rock formation (original)
                { x1: 1279, y1: 398, x2: 1477, y2: 533 },
                // Zone 2: Left side rock formation (original)
                { x1: 113, y1: 501, x2: 391, y2: 674 },
                
                // LEFT TRIANGLE - stacked rectangles from bottom-left corner
                // Bottom slice (widest)
                { x1: 0, y1: 1000, x2: 480, y2: 1080 },
                { x1: 0, y1: 920, x2: 400, y2: 1000 },
                { x1: 0, y1: 840, x2: 320, y2: 920 },
                { x1: 0, y1: 760, x2: 240, y2: 840 },
                { x1: 0, y1: 680, x2: 160, y2: 760 },
                { x1: 0, y1: 600, x2: 80, y2: 680 },
                
                // RIGHT TRIANGLE - stacked rectangles from bottom-right corner
                // Bottom slice (widest)
                { x1: 1440, y1: 1000, x2: 1920, y2: 1080 },
                { x1: 1520, y1: 920, x2: 1920, y2: 1000 },
                { x1: 1600, y1: 840, x2: 1920, y2: 920 },
                { x1: 1680, y1: 760, x2: 1920, y2: 840 },
                { x1: 1760, y1: 680, x2: 1920, y2: 760 },
                { x1: 1840, y1: 600, x2: 1920, y2: 680 }
            ],
            playerAreaOffsetX: 80,
            playerAreaOffsetY: 380
        };

        let gameState = {
            phase: 'idle',
            bossPhase: 1,
            players: {},
            boss: { health: CONFIG.phase1Health, maxHealth: CONFIG.phase1Health },
            totalDamage: 0,
            gameStartTime: null,
            timers: {},
            moveInterval: null,
            activeProjectiles: [],
            animationFrame: 1,
            animationInterval: null,
            attackCount: 0
        };

        // Audio
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;
        function initAudio() { if (!audioCtx) audioCtx = new AudioContext(); }
        
        // Boss animation frame switcher
        function setBossFrame(frame) {
            if (elements.bossImage && BATSY_FRAMES[frame]) {
                elements.bossImage.src = BATSY_FRAMES[frame];
            }
        }
        
        // Player animation system
        function startPlayerAnimation() {
            if (gameState.animationInterval) return;
            gameState.animationFrame = 1;
            gameState.animationInterval = setInterval(() => {
                gameState.animationFrame = (gameState.animationFrame % 5) + 1;
                updateAllPlayerFrames();
            }, 120); // 120ms per frame = ~8 FPS animation
        }
        
        function stopPlayerAnimation() {
            if (gameState.animationInterval) {
                clearInterval(gameState.animationInterval);
                gameState.animationInterval = null;
            }
            gameState.animationFrame = 1;
            updateAllPlayerFrames();
        }
        
        function updateAllPlayerFrames() {
            document.querySelectorAll('.player-sprite-container').forEach(el => {
                const username = el.dataset.username;
                const player = gameState.players[username];
                if (!player || !player.alive) return;
                
                const frame = gameState.animationFrame || 1;
                
                // Update knight body
                const knightImg = el.querySelector('.knight-image');
                if (knightImg && KNIGHT_FRAMES[frame]) {
                    knightImg.src = KNIGHT_FRAMES[frame];
                }
                
                // Update weapon arm (bow)
                const armImg = el.querySelector('.player-arm-img');
                if (armImg && WEAPON_ARM_FRAMES.bow[frame]) {
                    armImg.src = WEAPON_ARM_FRAMES.bow[frame];
                }
            });
        }
        
        // Check if a player position collides with any restricted zone
        function isInRestrictedZone(playerX, playerY) {
            // Convert player-area coordinates to screen coordinates
            const screenX = CONFIG.playerAreaOffsetX + playerX;
            const screenY = CONFIG.playerAreaOffsetY + playerY;
            
            // Player hitbox (approximate center point with some padding)
            const hitboxPadding = 20;
            const pLeft = screenX;
            const pRight = screenX + CONFIG.playerHitboxWidth;
            const pTop = screenY;
            const pBottom = screenY + CONFIG.playerHitboxHeight;
            
            for (const zone of CONFIG.restrictedZones) {
                // Check for rectangle intersection
                if (pRight > zone.x1 && pLeft < zone.x2 && 
                    pBottom > zone.y1 && pTop < zone.y2) {
                    return true;
                }
            }
            return false;
        }
        
        // Get a valid spawn X position (not in restricted zones)
        function getValidSpawnX() {
            let x, attempts = 0;
            do {
                x = 80 + Math.random() * (CONFIG.playAreaWidth - 160);
                attempts++;
            } while (isInRestrictedZone(x, 80 + Math.random() * (CONFIG.playAreaHeight - 160)) && attempts < 50);
            return x;
        }
        
        // Get a valid spawn Y position (not in restricted zones)
        function getValidSpawnY() {
            let y, attempts = 0;
            do {
                y = 80 + Math.random() * (CONFIG.playAreaHeight - 160);
                attempts++;
            } while (isInRestrictedZone(80 + Math.random() * (CONFIG.playAreaWidth - 160), y) && attempts < 50);
            return y;
        }
        
        // Get valid spawn position (both X and Y checked together)
        function getValidSpawnPosition() {
            let x, y, attempts = 0;
            do {
                x = 80 + Math.random() * (CONFIG.playAreaWidth - 160);
                y = 80 + Math.random() * (CONFIG.playAreaHeight - 160);
                attempts++;
            } while (isInRestrictedZone(x, y) && attempts < 50);
            return { x, y };
        }
        
        function playSound(type) {
            if (!audioCtx) return;
            
            // Helper to create 8-bit style sounds with multiple oscillators
            function createTone(freq, duration, waveType, volume, freqEnd) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = waveType;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                if (freqEnd) osc.frequency.exponentialRampToValueAtTime(freqEnd, audioCtx.currentTime + duration);
                gain.gain.setValueAtTime(volume, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            }
            
            switch(type) {
                case 'attack':
                    // 8-bit laser/sword swing - descending arpeggio
                    createTone(880, 0.05, 'square', 0.15);
                    setTimeout(() => createTone(660, 0.05, 'square', 0.12), 30);
                    setTimeout(() => createTone(440, 0.08, 'square', 0.1), 60);
                    break;
                    
                case 'heal':
                    // Rising magical chime - ascending notes
                    createTone(523, 0.1, 'sine', 0.12);
                    setTimeout(() => createTone(659, 0.1, 'sine', 0.12), 80);
                    setTimeout(() => createTone(784, 0.15, 'sine', 0.1), 160);
                    setTimeout(() => createTone(1047, 0.2, 'sine', 0.08), 240);
                    break;
                    
                case 'slam':
                    // Heavy impact - low rumble with punch
                    createTone(60, 0.3, 'sawtooth', 0.35, 25);
                    createTone(120, 0.15, 'square', 0.2, 40);
                    setTimeout(() => createTone(80, 0.2, 'triangle', 0.15, 30), 50);
                    break;
                    
                case 'frenzy':
                    // Aggressive rapid fire - intense 8-bit
                    createTone(200, 0.08, 'square', 0.2, 80);
                    setTimeout(() => createTone(250, 0.08, 'square', 0.18, 100), 40);
                    setTimeout(() => createTone(180, 0.1, 'sawtooth', 0.15, 60), 80);
                    break;
                    
                case 'hit':
                    // Player taking damage - sharp impact
                    createTone(200, 0.08, 'square', 0.2, 50);
                    createTone(100, 0.1, 'sawtooth', 0.15, 30);
                    break;
                    
                case 'playerHit':
                    // Boss taking damage - satisfying crunch
                    createTone(600, 0.06, 'square', 0.18, 200);
                    setTimeout(() => createTone(400, 0.08, 'sawtooth', 0.12, 150), 40);
                    break;
                    
                case 'death':
                    // Player death - dramatic descending
                    createTone(400, 0.15, 'square', 0.2, 100);
                    setTimeout(() => createTone(300, 0.15, 'square', 0.18, 80), 100);
                    setTimeout(() => createTone(200, 0.2, 'sawtooth', 0.15, 50), 200);
                    setTimeout(() => createTone(100, 0.3, 'sawtooth', 0.12, 30), 300);
                    break;
                    
                case 'phase2':
                    // Epic phase transition - dramatic warning
                    for (let i = 0; i < 4; i++) {
                        setTimeout(() => {
                            createTone(80 + i * 20, 0.25, 'sawtooth', 0.3 - i * 0.05, 40);
                            createTone(160 + i * 40, 0.2, 'square', 0.2 - i * 0.03, 80);
                        }, i * 180);
                    }
                    // Final impact
                    setTimeout(() => {
                        createTone(50, 0.4, 'sawtooth', 0.35, 25);
                        createTone(100, 0.3, 'square', 0.25, 50);
                    }, 720);
                    break;
                    
                case 'victory':
                    // Triumphant fanfare
                    const victoryNotes = [523, 659, 784, 1047, 784, 1047];
                    victoryNotes.forEach((freq, i) => {
                        setTimeout(() => createTone(freq, 0.2, 'square', 0.15), i * 120);
                    });
                    break;
                    
                case 'defeat':
                    // Sad game over
                    const defeatNotes = [400, 350, 300, 250, 200];
                    defeatNotes.forEach((freq, i) => {
                        setTimeout(() => createTone(freq, 0.25, 'sawtooth', 0.2 - i * 0.03, freq * 0.5), i * 200);
                    });
                    break;
            }
        }

        const elements = {
            game: document.getElementById('game'),
            playerArea: document.getElementById('player-area'),
            playerCount: document.getElementById('player-count'),
            aliveCount: document.getElementById('alive-count'),
            gameTimer: document.getElementById('game-timer'),
            totalDamage: document.getElementById('total-damage'),
            bossHealthFill: document.getElementById('boss-health-fill'),
            bossHealthText: document.getElementById('boss-health-text'),
            bossPhase: document.getElementById('boss-phase'),
            bossSprite: document.getElementById('boss-sprite'),
            bossImage: document.getElementById('boss-image'),
            lobbyOverlay: document.getElementById('lobby-overlay'),
            lobbyTimer: document.getElementById('lobby-timer'),
            lobbyPlayerList: document.getElementById('lobby-player-list'),
            bossIntroOverlay: document.getElementById('boss-intro-overlay'),
            phase2Overlay: document.getElementById('phase2-overlay'),
            victoryScreen: document.getElementById('victory-screen'),
            defeatScreen: document.getElementById('defeat-screen'),
            battleLog: document.getElementById('battle-log'),
            floatingTextContainer: document.getElementById('floating-text-container'),
            projectilesContainer: document.getElementById('projectiles-container'),
            commandHints: document.getElementById('command-hints')
        };

        function getBossCenter() {
            const bossRect = elements.bossImage.getBoundingClientRect();
            const gameRect = elements.game.getBoundingClientRect();
            return {
                x: bossRect.left - gameRect.left + bossRect.width / 2,
                y: bossRect.top - gameRect.top + bossRect.height / 2
            };
        }

        // Twitch
        const client = new tmi.Client({ channels: ['geor0se'] });
        client.connect().then(() => addBattleLog('System', 'Connected to Twitch!', 'system')).catch(err => {
            console.error('Twitch connection error:', err);
            addBattleLog('System', 'Connection failed - check console', 'system');
        });

        client.on('message', (channel, tags, message, self) => {
            if (self) return;
            /*const isMod = tags.mod || tags.badges?.broadcaster === '1';*/
            const isMod = tags.mod || tags.badges?.broadcaster || tags.username.toLowerCase() === 'geor0se';
            handleCommand(tags['display-name'] || tags.username, message.toLowerCase().trim(), isMod);
        });

        function handleCommand(username, message, isMod = false) {
            switch (gameState.phase) {
                case 'lobby': if (message === '!play') joinGame(username); break;
                case 'battle':
                    if (message === '!attack') playerAttack(username);
                    else if (message.startsWith('!heal')) playerHeal(username, message.split(' ')[1]);
                    else if (message === '!shield') playerShield(username);
                    else if (message.startsWith('!taunt')) playerTaunt(username, message);
                    break;
            }
            if ((message === '!bossfight' || message === '!startboss') && isMod) startLobby();
        }

        function startPlayerMovement() {
            if (gameState.moveInterval) clearInterval(gameState.moveInterval);
            gameState.moveInterval = setInterval(() => {
                Object.values(gameState.players).forEach(player => {
                    if (!player.alive) return;
                    
                    // More random direction changes for variety
                    if (Math.random() < 0.04) player.direction = Math.random() * Math.PI * 2;
                    // Occasionally reverse direction
                    if (Math.random() < 0.02) player.direction += Math.PI;
                    
                    let newX = player.x + Math.cos(player.direction) * CONFIG.playerMoveSpeed;
                    let newY = player.y + Math.sin(player.direction) * CONFIG.playerMoveSpeed;
                    
                    const margin = 30;
                    if (newX < margin || newX > CONFIG.playAreaWidth - margin) {
                        player.direction = Math.PI - player.direction + (Math.random() - 0.5) * 0.5;
                        newX = Math.max(margin, Math.min(CONFIG.playAreaWidth - margin, newX));
                    }
                    if (newY < margin || newY > CONFIG.playAreaHeight - margin) {
                        player.direction = -player.direction + (Math.random() - 0.5) * 0.5;
                        newY = Math.max(margin, Math.min(CONFIG.playAreaHeight - margin, newY));
                    }
                    
                    // Check restricted zones collision
                    if (isInRestrictedZone(newX, newY)) {
                        // Bounce off the restricted zone
                        player.direction += Math.PI + (Math.random() - 0.5) * 0.5;
                        newX = player.x;
                        newY = player.y;
                    }
                    
                    player.x = newX;
                    player.y = newY;
                    
                    const el = document.querySelector(`[data-username="${player.username}"]`);
                    if (el) {
                        el.style.left = player.x + 'px';
                        el.style.top = player.y + 'px';
                        const img = el.querySelector('.knight-image');
                        const arm = el.querySelector('.player-arm-img');
                        const flipTransform = Math.cos(player.direction) < 0 ? 'scaleX(-1)' : 'scaleX(1)';
                        if (img) img.style.transform = flipTransform;
                        if (arm) arm.style.transform = flipTransform;
                    }
                });
            }, CONFIG.playerMoveInterval);
        }

        function stopPlayerMovement() {
            if (gameState.moveInterval) { clearInterval(gameState.moveInterval); gameState.moveInterval = null; }
        }

        function startLobby() {
            if (gameState.phase !== 'idle') return;
            initAudio();
            gameState.phase = 'lobby';
            gameState.bossPhase = 1;
            gameState.players = {};
            gameState.totalDamage = 0;
            gameState.activeProjectiles = [];
            elements.game.classList.remove('phase2');
            resetBoss();
            updateUI();
            
            elements.lobbyOverlay.classList.add('active');
            elements.lobbyPlayerList.innerHTML = '';
            
            let timeLeft = CONFIG.lobbyDuration;
            elements.lobbyTimer.textContent = timeLeft;
            
            gameState.timers.lobby = setInterval(() => {
                timeLeft--;
                elements.lobbyTimer.textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(gameState.timers.lobby);
                    Object.keys(gameState.players).length >= 1 ? startBossIntro() : (endGame('idle'), addBattleLog('System', 'Not enough players!', 'system'));
                }
            }, 1000);
            
            addBattleLog('System', 'Type !play to join!', 'system');
        }

        function startBossIntro() {
            gameState.phase = 'intro';
            elements.lobbyOverlay.classList.remove('active');
            elements.bossIntroOverlay.classList.add('active');
            renderPlayers();
            
            // Countdown timer for intro screen
            let introTimeLeft = CONFIG.bossIntroDuration;
            const introTimerEl = document.getElementById('intro-timer');
            if (introTimerEl) {
                introTimerEl.textContent = introTimeLeft;
            }
            
            gameState.timers.intro = setInterval(() => {
                introTimeLeft--;
                if (introTimerEl) {
                    introTimerEl.textContent = introTimeLeft;
                }
                if (introTimeLeft <= 0) {
                    clearInterval(gameState.timers.intro);
                    elements.bossIntroOverlay.classList.remove('active');
                    startBattle();
                }
            }, 1000);
        }

        function startBattle() {
            gameState.phase = 'battle';
            gameState.gameStartTime = Date.now();
            gameState.attackCount = 0;  // Reset attack counter for side rain
            elements.commandHints.style.display = 'flex';
            startPlayerMovement();
            document.querySelectorAll('.player-sprite-container').forEach(el => el.classList.add('walking'));
            startPlayerAnimation();
            
            gameState.timers.bossAttack = setInterval(bossAttack, CONFIG.phase1AttackInterval);
            gameState.timers.gameTimer = setInterval(updateGameTimer, 1000);
            
            addBattleLog('System', 'BATTLE START!', 'system');
        }

        function transitionToPhase2() {
            gameState.bossPhase = 2;
            
            // Clear current attack timer
            clearInterval(gameState.timers.bossAttack);
            
            // Show phase 2 transition
            elements.phase2Overlay.classList.add('active');
            elements.game.classList.add('phase2');
            elements.game.classList.add('shaking');
            
            playSound('phase2');
            
            // Update boss health to phase 2
            gameState.boss.health = CONFIG.phase2Health;
            gameState.boss.maxHealth = CONFIG.phase2Health;
            updateBossHealth();
            elements.bossPhase.textContent = 'SLAM FRENZY';
            
            addBattleLog('BATSY', 'ENTERS PHASE 2!', 'boss');
            
            setTimeout(() => {
                elements.game.classList.remove('shaking');
            }, 500);
            
            setTimeout(() => {
                elements.phase2Overlay.classList.remove('active');
                // Start phase 2 attacks (faster)
                gameState.timers.bossAttack = setInterval(bossAttack, CONFIG.phase2AttackInterval);
            }, 1500);
        }

        function endGame(result) {
            gameState.phase = result;
            Object.values(gameState.timers).forEach(t => clearInterval(t));
            gameState.timers = {};
            stopPlayerMovement();
            
            ['lobbyOverlay', 'bossIntroOverlay', 'phase2Overlay'].forEach(o => elements[o].classList.remove('active'));
            elements.commandHints.style.display = 'none';
            document.querySelectorAll('.player-sprite-container').forEach(el => el.classList.remove('walking'));
            stopPlayerAnimation();
            
            if (result === 'victory') showVictoryScreen();
            else if (result === 'defeat') showDefeatScreen();
        }

        function joinGame(username) {
            if (gameState.players[username] || Object.keys(gameState.players).length >= CONFIG.maxPlayers) return;
            
            gameState.players[username] = {
                username,
                health: CONFIG.playerMaxHealth,
                maxHealth: CONFIG.playerMaxHealth,
                damage: 0,
                healing: 0,
                alive: true,
                lastAttack: 0,
                lastHeal: 0,
                lastShield: 0,
                shielded: false,
                tauntBoost: false,
                ...getValidSpawnPosition(),
                direction: Math.random() * Math.PI * 2
            };
            
            const item = document.createElement('div');
            item.className = 'player-list-item';
            item.innerHTML = `${username}`;
            elements.lobbyPlayerList.appendChild(item);
            
            updateUI();
            addBattleLog(username, 'joined the battle!', 'join');
        }

        function getDistanceMultiplier(player) {
            const dist = player.y / CONFIG.playAreaHeight;
            return CONFIG.maxDamageMultiplier - (dist * (CONFIG.maxDamageMultiplier - CONFIG.minDamageMultiplier));
        }

        function playerAttack(username) {
            const player = gameState.players[username];
            if (!player || !player.alive) return;
            if (player.shielded) return; // Can't attack while shielded
            if (Date.now() - player.lastAttack < CONFIG.attackCooldown) return;
            player.lastAttack = Date.now();
            
            initAudio();
            playSound('attack');
            
            const el = document.querySelector(`[data-username="${username}"]`);
            if (el) { el.classList.add('attacking'); setTimeout(() => el.classList.remove('attacking'), 250); }
            
            launchPlayerProjectile(player);
        }

        function launchPlayerProjectile(player) {
            const projectile = document.createElement('div');
            projectile.className = 'player-projectile';
            projectile.style.backgroundImage = `url(${PROJECTILE_IMAGES.bow})`;
            
            const bossCenter = getBossCenter();
            const startX = 80 + player.x + 24;
            const startY = CONFIG.playerAreaTop + player.y + 24;
            
            // Calculate angle to boss for arrow rotation (pointy end toward boss)
            const dx = bossCenter.x - startX;
            const dy = bossCenter.y - startY;
            const angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90; // +90 because arrow points up by default
            projectile.style.transform = `rotate(${angle}deg)`;
            
            projectile.style.left = startX + 'px';
            projectile.style.top = startY + 'px';
            
            elements.projectilesContainer.appendChild(projectile);
            
            const duration = 280;
            const startTime = performance.now();
            
            function animate(currentTime) {
                const progress = Math.min((currentTime - startTime) / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 2);
                
                projectile.style.left = (startX + (bossCenter.x - startX) * ease) + 'px';
                projectile.style.top = (startY + (bossCenter.y - startY) * ease) + 'px';
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    projectile.remove();
                    
                    const impact = document.createElement('div');
                    impact.className = 'impact player-impact';
                    impact.style.left = (bossCenter.x - 15) + 'px';
                    impact.style.top = bossCenter.y + 'px';
                    elements.projectilesContainer.appendChild(impact);
                    setTimeout(() => impact.remove(), 300);
                    
                    playSound('playerHit');
                    
                    const mult = getDistanceMultiplier(player);
                    let dmg = Math.floor(CONFIG.bowDamage * mult);
                    const crit = Math.random() < CONFIG.bowCritChance;
                    if (crit) dmg *= 2;
                    
                    // Apply taunt boost (50% extra damage)
                    if (player.tauntBoost) {
                        dmg = Math.floor(dmg * 1.5);
                        player.tauntBoost = false;
                    }
                    
                    gameState.boss.health = Math.max(0, gameState.boss.health - dmg);
                    player.damage += dmg;
                    gameState.totalDamage += dmg;
                    addBattleLog(player.username, `dealt ${dmg}${crit ? ' CRIT!' : ''} damage`, 'attack');
                    
                    elements.bossSprite.classList.add('damaged');
                    setTimeout(() => elements.bossSprite.classList.remove('damaged'), 150);
                    
                    createFloatingText(elements.bossSprite.getBoundingClientRect(), `-${dmg}${crit ? '!' : ''}`, crit ? 'crit' : 'damage');
                    updateBossHealth();
                    updateUI();
                    
                    // Check phase transition or victory
                    if (gameState.boss.health <= 0) {
                        if (gameState.bossPhase === 1) {
                            transitionToPhase2();
                        } else {
                            endGame('victory');
                        }
                    }
                }
            }
            
            requestAnimationFrame(animate);
        }

        function playerHeal(username, target) {
            const player = gameState.players[username];
            if (!player || !player.alive) return;
            if (player.shielded) return; // Can't heal while shielded
            if (Date.now() - player.lastHeal < CONFIG.healCooldown) return;
            player.lastHeal = Date.now();
            
            initAudio();
            playSound('heal');
            
            let healTarget = player;
            if (target && target.startsWith('@')) {
                const found = Object.values(gameState.players).find(p => p.username.toLowerCase() === target.substring(1).toLowerCase());
                if (found && found.alive) healTarget = found;
            }
            
            const amt = Math.min(CONFIG.healAmount, healTarget.maxHealth - healTarget.health);
            healTarget.health += amt;
            player.healing += amt;
            if (healTarget === player) {
                addBattleLog(player.username, `healed for ${amt}`, 'heal');
            } else {
                addBattleLog(player.username, `healed ${healTarget.username} for ${amt}`, 'heal');
            }
            
            const el = document.querySelector(`[data-username="${healTarget.username}"]`);
            if (el) {
                el.classList.add('healing');
                setTimeout(() => el.classList.remove('healing'), 500);
                createFloatingText(el.getBoundingClientRect(), `+${amt}`, 'heal');
            }
            
            updatePlayerSprite(healTarget.username);
        }

        function playerShield(username) {
            const player = gameState.players[username];
            if (!player || !player.alive) return;
            if (player.shielded) return; // Already shielded
            if (Date.now() - player.lastShield < 15000) return; // 15 second cooldown
            
            player.shielded = true;
            player.lastShield = Date.now();
            
            const el = document.querySelector(`[data-username="${username}"]`);
            if (el) {
                el.classList.add('shielded');
            }
            
            // Shield lasts 5 seconds
            setTimeout(() => {
                player.shielded = false;
                if (el) el.classList.remove('shielded');
            }, 5000);
        }
        
        function playerTaunt(username, message) {
            const player = gameState.players[username];
            if (!player || !player.alive) return;
            if (player.shielded) return; // Can't taunt while shielded
            if (Date.now() - (player.lastTaunt || 0) < 5000) return; // 5 second cooldown
            player.lastTaunt = Date.now();
            
            // Extract taunt message (after "!taunt ")
            const tauntText = message.substring(7).trim();
            if (tauntText.length === 0 || tauntText.length > 18) return; // Must be 1-18 chars
            
            // Give taunt boost for next attack
            player.tauntBoost = true;
            
            // Show speech bubble
            const el = document.querySelector(`[data-username="${username}"]`);
            if (el) {
                // Remove any existing bubble
                const existing = el.querySelector('.speech-bubble');
                if (existing) existing.remove();
                
                const bubble = document.createElement('div');
                bubble.className = 'speech-bubble';
                bubble.textContent = tauntText;
                el.appendChild(bubble);
                
                // Remove bubble after 3 seconds
                setTimeout(() => bubble.remove(), 3000);
            }
        }
        
        function resetBoss() {
            gameState.bossPhase = 1;
            gameState.boss = { health: CONFIG.phase1Health, maxHealth: CONFIG.phase1Health };
            updateBossHealth();
            elements.bossPhase.textContent = 'GROUND SLAM';
        }

        function bossAttack() {
            if (gameState.phase !== 'battle') return;
            
            const alive = Object.values(gameState.players).filter(p => p.alive);
            if (alive.length === 0) { endGame('defeat'); return; }
            
            initAudio();
            
            // Increment attack counter
            gameState.attackCount++;
            
            const isPhase2 = gameState.bossPhase === 2;
            const minProj = isPhase2 ? CONFIG.phase2ProjectilesMin : CONFIG.phase1ProjectilesMin;
            const maxProj = isPhase2 ? CONFIG.phase2ProjectilesMax : CONFIG.phase1ProjectilesMax;
            const hitChance = isPhase2 ? CONFIG.phase2HitChance : CONFIG.phase1HitChance;
            
            // Check if this is a side rain attack (every other attack)
            const shouldSideRain = gameState.attackCount % 2 === 0;
            
            // Randomized number of projectiles
            const numProjectiles = minProj + Math.floor(Math.random() * (maxProj - minProj + 1));
            
            // Animation
            if (isPhase2) {
                // Phase 2: Faster 3-frame animation cycle (fits within 400ms attack interval)
                // Frame 1: Pre-Slam wind-up
                setBossFrame('preslam');
                elements.bossSprite.classList.add('frenzied');
                
                // Frame 2: Slam impact (100ms later) - projectiles launch here
                setTimeout(() => {
                    setBossFrame('slam');
                    playSound('frenzy');
                    // Screen shake on phase 2
                    if (Math.random() < 0.3) {
                        elements.game.classList.add('shaking');
                        setTimeout(() => elements.game.classList.remove('shaking'), 200);
                    }
                    // Launch projectiles on slam impact
                    for (let i = 0; i < numProjectiles; i++) {
                        const delay = i * (30 + Math.random() * 50);
                        setTimeout(() => {
                            if (gameState.phase === 'battle') {
                                launchBossProjectile(hitChance, isPhase2);
                            }
                        }, delay);
                    }
                    // Launch side rain on every other attack
                    if (shouldSideRain && gameState.phase === 'battle') {
                        const sideRainCount = 1 + Math.floor(Math.random() * 3); // 1-3 per side (reduced 50%)
                        for (let i = 0; i < sideRainCount; i++) {
                            const delay = i * (80 + Math.random() * 60);
                            setTimeout(() => {
                                if (gameState.phase === 'battle') {
                                    launchSideRainProjectile('left', hitChance, isPhase2);
                                    launchSideRainProjectile('right', hitChance, isPhase2);
                                }
                            }, delay);
                        }
                    }
                }, 100);
                
                // Frame 3: Return to static (300ms total)
                setTimeout(() => {
                    setBossFrame('static');
                    elements.bossSprite.classList.remove('frenzied');
                }, 300);
            } else {
                // Phase 1: 3-frame animation cycle
                // Frame 1: Pre-Slam wind-up
                setBossFrame('preslam');
                elements.bossSprite.classList.add('slamming');
                
                // Frame 2: Slam impact (300ms later) - projectiles launch here
                setTimeout(() => {
                    setBossFrame('slam');
                    playSound('slam');
                    // Launch projectiles on slam impact
                    for (let i = 0; i < numProjectiles; i++) {
                        const delay = i * (50 + Math.random() * 100);
                        setTimeout(() => {
                            if (gameState.phase === 'battle') {
                                launchBossProjectile(hitChance, isPhase2);
                            }
                        }, delay);
                    }
                    // Launch side rain on every other attack
                    if (shouldSideRain && gameState.phase === 'battle') {
                        const sideRainCount = 3 + Math.floor(Math.random() * 3); // 3-5 per side (increased 50%)
                        for (let i = 0; i < sideRainCount; i++) {
                            const delay = i * (150 + Math.random() * 100);
                            setTimeout(() => {
                                if (gameState.phase === 'battle') {
                                    launchSideRainProjectile('left', hitChance, isPhase2);
                                    launchSideRainProjectile('right', hitChance, isPhase2);
                                }
                            }, delay);
                        }
                    }
                }, 300);
                
                // Frame 3: Return to static (800ms total)
                setTimeout(() => {
                    setBossFrame('static');
                    elements.bossSprite.classList.remove('slamming');
                }, 800);
            }
        }

        function launchBossProjectile(hitChance, isPhase2) {
            const projectile = document.createElement('div');
            projectile.className = 'boss-projectile' + (isPhase2 ? ' phase2' : '');
            
            // Randomly choose between large and small projectile images
            const projImage = Math.random() < 0.5 ? PROJECTILE_IMAGES.bossLarge : PROJECTILE_IMAGES.bossSmall;
            projectile.style.backgroundImage = `url(${projImage})`;
            
            const bossCenter = getBossCenter();
            
            // 175 degree arc: focused downward spread to hit edge players
            // Angle range: -87.5 to +87.5 degrees from straight down (90 degrees)
            // This means projectiles can go from nearly horizontal-left to nearly horizontal-right
            const spreadAngle = (Math.random() - 0.5) * Math.PI * 0.97; // ~175 degrees spread
            const baseAngle = Math.PI / 2; // 90 degrees = straight down
            const angle = baseAngle + spreadAngle;
            
            // Randomized speed
            const baseSpeed = isPhase2 ? 6.5 : 5;
            const speed = baseSpeed + Math.random() * 3.5;
            
            // Calculate velocity - proper trigonometry for full spread
            // At spreadAngle = 0: goes straight down
            // At spreadAngle = -87.5°: goes mostly left with slight downward
            // At spreadAngle = +87.5°: goes mostly right with slight downward
            let vx = Math.cos(angle) * speed;
            let vy = Math.sin(angle) * speed * 0.6; // Slightly reduce vertical to give more horizontal travel time
            
            // Wider starting position spread from boss sprite edges
            const spreadX = (Math.random() - 0.5) * 250;
            let x = bossCenter.x + spreadX;
            let y = bossCenter.y + 40;
            
            projectile.style.left = x + 'px';
            projectile.style.top = y + 'px';
            
            elements.projectilesContainer.appendChild(projectile);
            
            // Determine if this projectile can hit (with randomized chance)
            const actualHitChance = hitChance + (Math.random() - 0.5) * 0.2; // 40-60% variance
            const willHit = Math.random() < actualHitChance;
            
            const projectileData = { element: projectile, x, y, vx, vy, willHit, hasHit: false, isPhase2 };
            gameState.activeProjectiles.push(projectileData);
            
            function animate() {
                if (projectileData.hasHit || !projectile.parentNode) return;
                
                projectileData.x += projectileData.vx;
                projectileData.y += projectileData.vy;
                projectileData.vy += 0.18; // Gravity
                
                // Add slight wobble for phase 2
                if (projectileData.isPhase2) {
                    projectileData.x += Math.sin(projectileData.y * 0.05) * 0.5;
                }
                
                projectile.style.left = projectileData.x + 'px';
                projectile.style.top = projectileData.y + 'px';
                projectile.style.transform = `rotate(${projectileData.vy * 8}deg)`;
                
                // Hitbox collision
                if (projectileData.willHit) {
                    const alive = Object.values(gameState.players).filter(p => p.alive);
                    for (const player of alive) {
                        if (player.shielded) continue; // Skip shielded players
                        
                        const px = 80 + player.x;
                        const py = CONFIG.playerAreaTop + player.y;
                        
                        // Use actual projectile size for collision
                        const projSize = projectileData.isPhase2 ? CONFIG.phase2ProjectileSize : CONFIG.phase1ProjectileSize;
                        
                        if (projectileData.x > px - projSize &&
                            projectileData.x < px + CONFIG.playerHitboxWidth &&
                            projectileData.y > py - projSize &&
                            projectileData.y < py + CONFIG.playerHitboxHeight) {
                            
                            projectileData.hasHit = true;
                            projectile.remove();
                            
                            const impact = document.createElement('div');
                            impact.className = 'impact' + (projectileData.isPhase2 ? ' phase2' : '');
                            impact.style.left = (projectileData.x - 20) + 'px';
                            impact.style.top = projectileData.y + 'px';
                            elements.projectilesContainer.appendChild(impact);
                            setTimeout(() => impact.remove(), 400);
                            
                            const mult = getDistanceMultiplier(player);
                            let dmg = Math.floor(CONFIG.bossBaseDamage * mult * (0.7 + Math.random() * 0.6));
                            if (projectileData.isPhase2) dmg = Math.floor(dmg * 1.25);
                            
                            player.health -= dmg;
                            playSound('hit');
                            addBattleLog(player.username, `took ${dmg} damage`, 'hit');
                            
                            const el = document.querySelector(`[data-username="${player.username}"]`);
                            if (el) {
                                el.classList.add('damaged');
                                setTimeout(() => el.classList.remove('damaged'), 250);
                            }
                            
                            // Update health bar display
                            updatePlayerSprite(player.username);
                            
                            createFloatingText({ left: px, top: py, width: CONFIG.playerHitboxWidth, height: CONFIG.playerHitboxHeight }, `-${dmg}`, 'damage');
                            
                            if (player.health <= 0) {
                                player.health = 0;
                                player.alive = false;
                                playSound('death');
                                // Show death hit marker
                                const deathMarker = document.createElement('div');
                                deathMarker.className = 'impact death-marker';
                                deathMarker.style.left = (px - 30) + 'px';
                                deathMarker.style.top = (py - 30) + 'px';
                                elements.projectilesContainer.appendChild(deathMarker);
                                setTimeout(() => deathMarker.remove(), 600);
                                
                                createDeathEffect(px, py);
                                addBattleLog(player.username, 'defeated!', 'death');
                                updatePlayerSprite(player.username);
                            }
                            
                            updateUI();
                            if (Object.values(gameState.players).filter(p => p.alive).length === 0) endGame('defeat');
                            
                            const idx = gameState.activeProjectiles.indexOf(projectileData);
                            if (idx > -1) gameState.activeProjectiles.splice(idx, 1);
                            return;
                        }
                    }
                }
                
                // Off screen
                if (projectileData.y > 1100 || projectileData.x < -50 || projectileData.x > 1970) {
                    projectile.remove();
                    const idx = gameState.activeProjectiles.indexOf(projectileData);
                    if (idx > -1) gameState.activeProjectiles.splice(idx, 1);
                    return;
                }
                
                requestAnimationFrame(animate);
            }
            
            requestAnimationFrame(animate);
        }

        // Side rain projectiles - fall from top on left/right 25% of screen
        function launchSideRainProjectile(side, hitChance, isPhase2) {
            const projectile = document.createElement('div');
            projectile.className = 'rain-projectile' + (isPhase2 ? ' phase2' : '');
            
            // Randomly choose between large and small
            const rockImage = Math.random() < 0.5 
            ? FALL_PROJECTILE_IMAGES.rockSlideLarge 
            : FALL_PROJECTILE_IMAGES.rockSlideSmall;

            projectile.style.backgroundImage = `url(${rockImage})`;
            
            // Calculate x position based on side (left or right 25% of play area)
            // Play area starts at x=80 and is CONFIG.playAreaWidth wide
            const playAreaLeft = CONFIG.playerAreaOffsetX;
            const playAreaRight = playAreaLeft + CONFIG.playAreaWidth;
            const quarterWidth = CONFIG.playAreaWidth * 0.25;
            
            let x;
            if (side === 'left') {
                // Left 25%: from playAreaLeft to playAreaLeft + quarterWidth
                x = playAreaLeft + Math.random() * quarterWidth;
            } else {
                // Right 25%: from playAreaRight - quarterWidth to playAreaRight
                x = (playAreaRight - quarterWidth) + Math.random() * quarterWidth;
            }
            
            // Start above the screen
            let y = -30;
            
            // Fall straight down with some speed variation (20% faster)
            const baseSpeed = isPhase2 ? 6 : 4.8;
            const vy = baseSpeed + Math.random() * 2.4;
            const vx = (Math.random() - 0.5) * 0.5; // Very slight horizontal drift
            
            projectile.style.left = x + 'px';
            projectile.style.top = y + 'px';
            
            elements.projectilesContainer.appendChild(projectile);
            
            const actualHitChance = hitChance + (Math.random() - 0.5) * 0.2;
            const willHit = Math.random() < actualHitChance;
            
            const projectileData = { element: projectile, x, y, vx, vy, willHit, hasHit: false, isPhase2, isSideRain: true };
            gameState.activeProjectiles.push(projectileData);
            
            function animate() {
                if (projectileData.hasHit || !projectile.parentNode) return;
                
                projectileData.x += projectileData.vx;
                projectileData.y += projectileData.vy;
                // No gravity for side rain - constant fall speed
                
                projectile.style.left = projectileData.x + 'px';
                projectile.style.top = projectileData.y + 'px';
                
                // Check collision with players
                if (projectileData.willHit) {
                    const alivePlayers = Object.values(gameState.players).filter(p => p.alive);
                    for (const player of alivePlayers) {
                        if (player.shielded) continue;
                        
                        const px = CONFIG.playerAreaOffsetX + player.x;
                        const py = CONFIG.playerAreaOffsetY + player.y;
                        const projSize = projectileData.isPhase2 ? CONFIG.phase2ProjectileSize : CONFIG.phase1ProjectileSize;
                        
                        if (projectileData.x > px - projSize &&
                            projectileData.x < px + CONFIG.playerHitboxWidth &&
                            projectileData.y > py - projSize &&
                            projectileData.y < py + CONFIG.playerHitboxHeight) {
                            
                            projectileData.hasHit = true;
                            projectile.remove();
                            
                            const impact = document.createElement('div');
                            impact.className = 'impact' + (projectileData.isPhase2 ? ' phase2' : '');
                            impact.style.left = (projectileData.x - 20) + 'px';
                            impact.style.top = projectileData.y + 'px';
                            elements.projectilesContainer.appendChild(impact);
                            setTimeout(() => impact.remove(), 400);
                            
                            const mult = getDistanceMultiplier(player);
                            let dmg = Math.floor(CONFIG.bossBaseDamage * mult * (0.7 + Math.random() * 0.6));
                            if (projectileData.isPhase2) dmg = Math.floor(dmg * 1.25);
                            
                            player.health -= dmg;
                            playSound('hit');
                            addBattleLog(player.username, `took ${dmg} damage (side rain)`, 'hit');
                            
                            const el = document.querySelector(`[data-username="${player.username}"]`);
                            if (el) {
                                el.classList.add('damaged');
                                setTimeout(() => el.classList.remove('damaged'), 250);
                            }
                            
                            updatePlayerSprite(player.username);
                            createFloatingText({ left: px, top: py, width: CONFIG.playerHitboxWidth, height: CONFIG.playerHitboxHeight }, `-${dmg}`, 'damage');
                            
                            if (player.health <= 0) {
                                player.health = 0;
                                player.alive = false;
                                playSound('death');
                                const deathMarker = document.createElement('div');
                                deathMarker.className = 'impact death-marker';
                                deathMarker.style.left = (px - 30) + 'px';
                                deathMarker.style.top = (py - 30) + 'px';
                                elements.projectilesContainer.appendChild(deathMarker);
                                setTimeout(() => deathMarker.remove(), 600);
                                
                                createDeathEffect(px, py);
                                addBattleLog(player.username, 'defeated!', 'death');
                                updatePlayerSprite(player.username);
                            }
                            
                            updateUI();
                            if (Object.values(gameState.players).filter(p => p.alive).length === 0) endGame('defeat');
                            
                            const idx = gameState.activeProjectiles.indexOf(projectileData);
                            if (idx > -1) gameState.activeProjectiles.splice(idx, 1);
                            return;
                        }
                    }
                }
                
                // Off screen (bottom)
                if (projectileData.y > 1100) {
                    projectile.remove();
                    const idx = gameState.activeProjectiles.indexOf(projectileData);
                    if (idx > -1) gameState.activeProjectiles.splice(idx, 1);
                    return;
                }
                
                requestAnimationFrame(animate);
            }
            
            requestAnimationFrame(animate);
        }

        function updateUI() {
            elements.playerCount.textContent = `${Object.keys(gameState.players).length} / ${CONFIG.maxPlayers}`;
            elements.aliveCount.textContent = Object.values(gameState.players).filter(p => p.alive).length;
            elements.totalDamage.textContent = gameState.totalDamage.toLocaleString();
        }

        function updateBossHealth() {
            const pct = (gameState.boss.health / gameState.boss.maxHealth) * 100;
            elements.bossHealthFill.style.width = `${pct}%`;
            elements.bossHealthText.textContent = `${gameState.boss.health} / ${gameState.boss.maxHealth}`;
        }

        function updateGameTimer() {
            if (!gameState.gameStartTime) return;
            const s = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            elements.gameTimer.textContent = `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
        }

        function renderPlayers() {
            elements.playerArea.innerHTML = '';
            Object.values(gameState.players).forEach(player => {
                const container = document.createElement('div');
                container.className = `player-sprite-container ${player.alive ? '' : 'dead'}`;
                container.dataset.username = player.username;
                container.style.left = player.x + 'px';
                container.style.top = player.y + 'px';
                
                const healthPct = (player.health / player.maxHealth) * 100;
                const healthClass = healthPct <= 30 ? 'low' : healthPct <= 60 ? 'medium' : '';
                
                const frame = gameState.animationFrame || 1;
                const knightSrc = KNIGHT_FRAMES[frame] || KNIGHT_FRAMES[1];
                
                container.innerHTML = `
                    <img class="knight-image" src="${knightSrc}" alt="Knight">
                    <div class="player-info">
                        <div class="player-name">${player.username}</div>
                        <div class="player-health-bar">
                            <div class="player-health-fill ${healthClass}" style="width:${healthPct}%"></div>
                        </div>
                    </div>
                `;
                
                elements.playerArea.appendChild(container);
            });
        }

        function updatePlayerSprite(username) {
            const player = gameState.players[username];
            if (!player) return;
            
            const el = document.querySelector(`[data-username="${username}"]`);
            if (!el) return;
            
            el.className = `player-sprite-container ${player.alive ? '' : 'dead'} ${gameState.phase === 'battle' && player.alive ? 'walking' : ''}`;
            
            const healthPct = (player.health / player.maxHealth) * 100;
            const healthFill = el.querySelector('.player-health-fill');
            if (healthFill) {
                healthFill.style.width = healthPct + '%';
                const healthClass = healthPct <= 30 ? 'low' : healthPct <= 60 ? 'medium' : '';
                healthFill.className = `player-health-fill ${healthClass}`;
            }
            
            // Update knight frame
            const knightImg = el.querySelector('.knight-image');
            if (knightImg) {
                const frame = gameState.animationFrame || 1;
                knightImg.src = KNIGHT_FRAMES[frame] || KNIGHT_FRAMES[1];
            }
        }

        function createFloatingText(rect, text, type) {
            const el = document.createElement('div');
            el.className = `floating-text ${type}`;
            el.textContent = text;
            el.style.left = `${rect.left + rect.width/2}px`;
            el.style.top = `${rect.top}px`;
            elements.floatingTextContainer.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function createDeathEffect(x, y) {
            // Main death effect
            const deathEl = document.createElement('div');
            deathEl.className = 'death-effect';
            deathEl.style.left = (x + 24) + 'px';
            deathEl.style.top = (y + 24) + 'px';
            elements.projectilesContainer.appendChild(deathEl);
            setTimeout(() => deathEl.remove(), 800);
            
            // Particle burst
            const numParticles = 8;
            for (let i = 0; i < numParticles; i++) {
                const particle = document.createElement('div');
                particle.className = 'death-particle';
                particle.style.left = (x + 24) + 'px';
                particle.style.top = (y + 24) + 'px';
                
                const angle = (i / numParticles) * Math.PI * 2;
                const speed = 3 + Math.random() * 3;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                elements.projectilesContainer.appendChild(particle);
                
                let px = x + 24, py = y + 24;
                let life = 1;
                
                function animateParticle() {
                    px += vx;
                    py += vy + 0.5; // slight gravity
                    life -= 0.03;
                    
                    particle.style.left = px + 'px';
                    particle.style.top = py + 'px';
                    particle.style.opacity = life;
                    particle.style.transform = `scale(${life})`;
                    
                    if (life > 0) {
                        requestAnimationFrame(animateParticle);
                    } else {
                        particle.remove();
                    }
                }
                
                requestAnimationFrame(animateParticle);
            }
        }

        function addBattleLog(name, action, type) {
            const entry = document.createElement('div');
            entry.className = 'battle-log-entry';
            let color = 'var(--rose)';
            if (type === 'boss') color = 'var(--phase2-orange)';
            else if (type === 'system') color = 'var(--lavender)';
            else if (type === 'attack') color = 'var(--gold)';
            else if (type === 'heal') color = 'var(--health-green)';
            else if (type === 'hit') color = 'var(--health-red)';
            else if (type === 'death') color = '#888';
            entry.innerHTML = `<span style="color:${color}">${name}</span> ${action}`;
            elements.battleLog.appendChild(entry);
            elements.battleLog.scrollTop = elements.battleLog.scrollHeight;
            while (elements.battleLog.children.length > 51) elements.battleLog.children[1].remove();
        }

        function showVictoryScreen() {
            playSound('victory');
            const players = Object.values(gameState.players);
            const mvp = players.reduce((best, p) => (p.damage + p.healing) > (best.damage + best.healing) ? p : best, players[0]);
            
            document.getElementById('mvp-name').textContent = mvp.username;
            document.getElementById('mvp-damage').textContent = mvp.damage.toLocaleString();
            document.getElementById('mvp-healing').textContent = mvp.healing.toLocaleString();
            
            const grid = document.getElementById('victory-stats');
            grid.innerHTML = '';
            players.sort((a,b) => (b.damage + b.healing) - (a.damage + a.healing)).slice(0, 10).forEach(p => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `<div class="stat-card-name">${p.username}</div><div class="stat-card-damage">⚔️ ${p.damage}</div><div class="stat-card-healing">❤️ ${p.healing}</div>`;
                grid.appendChild(card);
            });
            
            elements.victoryScreen.classList.add('active');
        }

        function showDefeatScreen() {
            playSound('defeat');
            const players = Object.values(gameState.players);
            const mvp = players.reduce((best, p) => (p.damage + p.healing) > (best.damage + best.healing) ? p : best, players[0]);
            
            document.getElementById('defeat-mvp-name').textContent = mvp ? mvp.username : 'No one';
            document.getElementById('defeat-boss-hp').textContent = gameState.boss.health;
            document.getElementById('defeat-team-damage').textContent = gameState.totalDamage.toLocaleString();
            
            elements.defeatScreen.classList.add('active');
        }

        // Keyboard controls
        /*document.addEventListener('keydown', e => {
            if (e.key === 'Enter') startLobby();
            if (e.key === '1') handleCommand('Player1', '!play');
            if (e.key === '2') handleCommand('Player2', '!play');
            if (e.key === '3') handleCommand('Player3', '!play');
            if (e.key === '4') handleCommand('Player4', '!play');
            if (e.key === '5') handleCommand('Player5', '!play');
            if (e.key === 'a') handleCommand('Player1', '!attack');
            if (e.key === 's') handleCommand('Player2', '!attack');
            if (e.key === 'd') handleCommand('Player3', '!attack');
            if (e.key === 'f') handleCommand('Player4', '!attack');
            if (e.key === 'g') handleCommand('Player5', '!attack');
            if (e.key === 'h') handleCommand('Player1', '!heal');
            if (e.key === 'r') handleCommand('Player1', '!shield');
            if (e.key === 't') handleCommand('Player1', '!taunt You smell bad!');
        });

        console.log('GeoRose Boss Battle v5 - Batsy The Beast');
        console.log('ENTER=start, 1-5=join, A/S/D/F/G=attack, H=heal, R=shield, T=taunt');*/
    </script>
</body>
</html>

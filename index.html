<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoRose - Batsy Boss Battle</title>
    <script src="tmi.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #1a1520;
            --bg-medium: #2E2733;
            --lavender: #9A82A9;
            --rose: #F6AAB4;
            --cream: #FFF8FC;
            --health-green: #7BC96F;
            --health-red: #E85C5C;
            --gold: #FEE590;
            --player-attack: #FAE69B;
            --rage-orange: #FF6B35;
            --shield-marker: url('images/hit_marker_shield.PNG');
        }

        body {
            font-family: 'VT323', monospace;
            background: var(--bg-dark);
            color: var(--cream);
            overflow: hidden;
            width: 1920px;
            height: 1080px;
        }

        .game-container {
            width: 1920px;
            height: 1080px;
            position: relative;
            overflow: hidden;
        }

        .cave-background {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-image: url('images/background.PNG');
            background-size: cover;
            background-position: center;
            z-index: 1;
        }

        .cave-background::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(26, 21, 32, 0.3);
            z-index: 2;
            transition: background 0.5s ease;
        }

        /* Rage mode darker atmosphere */
        .game-container.rage-mode .cave-background::after {
            background: rgba(26, 21, 32, 0.5);
        }
        .cave-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-image: url('images/background_overlay.PNG');
            background-size: cover;
            background-position: center;
            z-index: 35;
            pointer-events: none;
        }
        .cave-corner-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-image: url('images/background_overlay_corners.PNG');
            background-size: cover;
            background-position: center;
            z-index: 50;
            pointer-events: none;
        }


        /* Stream Windows - 15% larger */
        .stream-window {
            position: absolute;
            width: 389px;
            height: 219px;
            background: var(--bg-medium);
            border: 4px solid var(--lavender);
            border-radius: 8px;
            overflow: hidden;
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .stream-window.gameplay { top: 20px; left: 20px; }
        .stream-window.camera { top: 20px; right: 20px; }

        .stream-window-label {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            background: rgba(46, 39, 51, 0.95);
            padding: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            text-align: center;
            color: var(--rose);
            text-transform: uppercase;
        }

        .stream-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--lavender);
            font-size: 14px;
            text-align: center;
            background: repeating-linear-gradient(45deg, var(--bg-dark), var(--bg-dark) 10px, var(--bg-medium) 10px, var(--bg-medium) 20px);
        }

        /* Game Title */
        .game-title {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 28px;
            color: var(--rose);
            text-shadow: 3px 3px 0 var(--bg-medium), 5px 5px 0 var(--lavender);
            z-index: 50;
        }

        /* Boss Area */
        .boss-area {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 30;
        }

        .boss-health-container {
            width: 450px;
            margin-bottom: 10px;
        }

        .boss-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            color: var(--rose);
            margin-bottom: 5px;
            text-align: center;
            text-transform: uppercase;
            text-shadow: 2px 2px 0 var(--bg-dark);
            transition: color 0.3s ease;
        }

        .game-container.rage-mode .boss-name {
            color: var(--rage-orange);
        }

        .boss-health-bar {
            width: 100%;
            height: 28px;
            background: var(--bg-medium);
            border: 3px solid var(--lavender);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            transition: border-color 0.3s ease;
        }

        .game-container.rage-mode .boss-health-bar {
            border-color: var(--rage-orange);
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(180deg, var(--health-red) 0%, #c44 100%);
            transition: width 0.3s ease, background 0.3s ease;
            position: relative;
        }

        .game-container.rage-mode .boss-health-fill {
            background: linear-gradient(180deg, var(--rage-orange) 0%, #cc4420 100%);
        }

        .boss-health-fill::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3) 0%, transparent 100%);
        }

        .boss-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
            color: var(--cream);
            text-shadow: 1px 1px 0 var(--bg-dark);
            z-index: 5;
        }

        .boss-phase {
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: var(--gold);
            margin-top: 13px;
            text-align: center;
            text-shadow: 1px 1px 0 var(--bg-dark);
            transition: color 0.3s ease;
        }

        .game-container.rage-mode .boss-phase {
            color: var(--rage-orange);
            animation: phaseGlow 0.5s ease-in-out infinite alternate;
        }

        @keyframes phaseGlow {
            0% { text-shadow: 1px 1px 0 var(--bg-dark), 0 0 10px var(--rage-orange); }
            100% { text-shadow: 1px 1px 0 var(--bg-dark), 0 0 20px var(--rage-orange); }
        }

        /* Boss Sprite - Batsy */
        .boss-sprite-container {
            position: relative;
            width: 350px;
            height: 280px;
        }

        .boss-sprite {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .boss-image {
            width: 438px;
            height: auto;
            animation: bossIdle 1.5s ease-in-out infinite;
            filter: drop-shadow(0 8px 20px rgba(0,0,0,0.6));
            transition: filter 0.3s ease;
        }

        .game-container.rage-mode .boss-image {
            filter: drop-shadow(0 8px 20px rgba(0,0,0,0.6)) drop-shadow(0 0 20px rgba(255, 107, 53, 0.5));
        }

        @keyframes bossIdle {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-8px) scale(1.02); }
        }

        /* Phase 1: Ground slam animation */
        .boss-sprite.slamming .boss-image {
            animation: bossSlam 0.5s ease;
        }

        @keyframes bossSlam {
            0% { transform: translateY(0) scale(1); }
            30% { transform: translateY(-20px) scale(1.05); }
            60% { transform: translateY(15px) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }

        /* Rage mode: Frenzy animation */
        .boss-sprite.frenzied .boss-image {
            animation: bossFrenzy 0.3s ease;
        }

        @keyframes bossFrenzy {
            0% { transform: translateX(0) scale(1.05); }
            25% { transform: translateX(-10px) scale(1.08); }
            50% { transform: translateX(10px) scale(1.08); }
            75% { transform: translateX(-5px) scale(1.05); }
            100% { transform: translateX(0) scale(1.05); }
        }

        .boss-sprite.damaged .boss-image {
            animation: bossDamaged 0.15s ease !important;
        }

        @keyframes bossDamaged {
            0%, 100% { filter: brightness(1) drop-shadow(0 5px 15px rgba(0,0,0,0.5)); }
            50% { filter: brightness(2.5) hue-rotate(30deg) drop-shadow(0 5px 20px rgba(255,255,255,0.5)); }
        }

        /* Boss death sequence */
        .boss-sprite.death-shake .boss-image {
            animation: bossDeathShake 0.8s ease !important;
        }

        @keyframes bossDeathShake {
            0% { transform: translateX(0) scale(1); filter: brightness(1); }
            10% { transform: translateX(-12px) scale(1.05); filter: brightness(2); }
            20% { transform: translateX(12px) scale(1.05); filter: brightness(1.5); }
            30% { transform: translateX(-8px) scale(1.03); filter: brightness(2.5); }
            40% { transform: translateX(8px) scale(1.03); filter: brightness(1.5); }
            50% { transform: translateX(-5px) scale(1.02); filter: brightness(2); }
            60% { transform: translateX(5px) scale(1.02); filter: brightness(1.5); }
            70% { transform: translateX(-3px) scale(1.01); filter: brightness(1.8); }
            80% { transform: translateX(3px) scale(1); filter: brightness(1.3); }
            90% { transform: translateX(-1px) scale(1); filter: brightness(1.1); }
            100% { transform: translateX(0) scale(1); filter: brightness(1); }
        }

        .boss-sprite.death-collapse .boss-image {
            animation: bossDeathCollapse 1s ease-in forwards !important;
        }

        @keyframes bossDeathCollapse {
            0% { transform: translateY(0) scale(1) rotate(0deg); opacity: 1; filter: brightness(1); }
            30% { transform: translateY(-15px) scale(1.05) rotate(-2deg); opacity: 1; filter: brightness(1.5); }
            100% { transform: translateY(20px) scale(0.95) rotate(3deg); opacity: 1; filter: brightness(1) saturate(1); }
        }

        .boss-sprite.death-final .boss-image {
            filter: brightness(1) saturate(1);
            animation: none !important;
        }

        /* Boss Projectiles - using sprite images */
        .boss-projectile {
            position: absolute;
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 40;
            pointer-events: none;
            /*image-rendering: pixelated;*/
        }

        /* Boss Projectiles - Rage mode */
        .boss-projectile.rage {
            width: 50px;
            height: 50px;
            filter: drop-shadow(0 0 8px rgba(255, 107, 53, 0.7));
        }

        /* Boss Projectiles - using sprite images */
        .rain-projectile {
            position: absolute;
            width: 70px;
            height: 70px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 40;
            pointer-events: none;
            /*image-rendering: pixelated;*/
        }

        /* Boss Projectiles - Rage mode */
        .rain-projectile.rage {
            width: 80px;
            height: 80px;
            filter: drop-shadow(0 0 8px rgba(255, 107, 53, 0.7));
        }

        /* Player Projectiles - Arrow */
        .player-projectile {
            position: absolute;
            width: 14px;
            height: 22px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 25;
            pointer-events: none;
            /*image-rendering: pixelated;*/
            filter: drop-shadow(0 0 4px rgba(250, 230, 155, 0.6));
        }

        /* Impact Effects - Using custom hit markers */
        .impact {
            position: absolute;
            width: 50px;
            height: 50px;
            z-index: 41;
            pointer-events: none;
            background-image: url('images/hit_marker_damage.PNG');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            /*image-rendering: pixelated;*/
            animation: impactPop 0.4s ease-out forwards;
        }

        .impact.player-impact {
            width: 45px;
            height: 45px;
        }

        .impact.rage {
            width: 55px;
            height: 55px;
            filter: hue-rotate(-20deg) brightness(1.2);
        }
        
        .impact.death-marker {
            width: 60px;
            height: 60px;
            background-image: url('images/hit_marker_death.PNG');
            animation: impactPop 0.6s ease-out forwards;
        }

        @keyframes impactPop {
            0% { transform: scale(0.3); opacity: 1; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        /* Death Effect */
        .death-effect {
            position: absolute;
            width: 80px;
            height: 80px;
            z-index: 200;
            pointer-events: none;
        }

        .death-effect::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(232, 92, 92, 0.9) 0%, rgba(232, 92, 92, 0.3) 50%, transparent 70%);
            animation: deathFlash 0.6s ease-out forwards;
        }

        @keyframes deathFlash {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            30% { transform: translate(-50%, -50%) scale(2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }

        /* Particle burst on death */
        .death-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--health-red);
            border-radius: 50%;
            z-index: 199;
            pointer-events: none;
        }

        /* Screen shake for phase 2 */
        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-3px, -2px); }
            20% { transform: translate(3px, 2px); }
            30% { transform: translate(-2px, 3px); }
            40% { transform: translate(2px, -3px); }
            50% { transform: translate(-3px, 2px); }
            60% { transform: translate(3px, -2px); }
            70% { transform: translate(-2px, -3px); }
            80% { transform: translate(2px, 3px); }
            90% { transform: translate(-3px, -2px); }
        }

        .game-container.shaking {
            animation: screenShake 0.3s ease;
        }

        /* Player Area */
        .player-area {
            position: absolute;
            top: 380px;
            left: 80px;
            right: 80px;
            bottom: 160px;
            z-index: 20;
        }

        /* Knight Sprites */
        .player-sprite-container {
            position: absolute;
            width: 61px;
            height: 76px;
            z-index: 20;
        }

        .player-sprite-container.dead {
            opacity: 0.7;
        }
        
        .player-sprite-container.dead .knight-image {
            content: url('images/death_state.PNG');
        }
        
        /* Shielded state - semi-transparent and immune */
        .player-sprite-container.shielded {
            opacity: 0.5;
            filter: drop-shadow(0 0 10px rgba(150, 200, 255, 0.8));
        }
        
        .player-sprite-container.shielded::before {
            content: '';
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 25px;
            background-image: var(--shield-marker);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 30;
            pointer-events: none;
        }
        
        /* Reviving state - progress bar under dead knight */
        .revive-bar-container {
            position: absolute;
            bottom: -32px;
            left: 50%;
            transform: translateX(-50%);
            width: 58px;
            text-align: center;
        }
        
        .revive-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: var(--lavender);
            text-shadow: 1px 1px 0 var(--bg-dark);
            margin-bottom: 2px;
        }
        
        .revive-bar {
            width: 100%;
            height: 6px;
            background: #1a1a2a;
            border: 1px solid var(--lavender);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .revive-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(180deg, var(--lavender) 0%, #7B6B8A 100%);
            transition: width 0.25s linear;
        }
        
        /* Revived state - uses ghost/skeleton sprite */
        .player-sprite-container.revived {
            filter: drop-shadow(0 0 8px rgba(154, 130, 169, 0.6));
        }
        
        @keyframes reviveFlash {
            0% { opacity: 0; transform: scale(0.5); filter: brightness(3) drop-shadow(0 0 20px rgba(154, 130, 169, 1)); }
            40% { opacity: 1; transform: scale(1.2); filter: brightness(2) drop-shadow(0 0 15px rgba(154, 130, 169, 0.8)); }
            100% { opacity: 1; transform: scale(1); filter: brightness(1) drop-shadow(0 0 8px rgba(154, 130, 169, 0.6)); }
        }
        
        .player-sprite-container.revive-flash {
            animation: reviveFlash 0.6s ease-out forwards;
        }
        
        /* Speech bubble for taunts */
        .speech-bubble {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            color: #333;
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 16px;
            font-family: 'VT323', monospace;
            white-space: nowrap;
            z-index: 100;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: bubblePop 0.2s ease-out;
        }
        
        .speech-bubble::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: white;
        }
        
        @keyframes bubblePop {
            0% { transform: translateX(-50%) scale(0); }
            50% { transform: translateX(-50%) scale(1.1); }
            100% { transform: translateX(-50%) scale(1); }
        }

        .knight-image {
            width: 61px;
            height: 61px;
            /*image-rendering: pixelated;*/
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.5));
        }

        .player-sprite-container.walking .knight-image {
            /* Animation handled by JavaScript frame switching */
        }

        .player-sprite-container.attacking .knight-image {
            animation: knightAttack 0.25s ease;
        }

        @keyframes knightAttack {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-10px) scale(1.15); }
        }

        .player-sprite-container.healing::before {
            content: '✨';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            animation: healSparkle 0.5s ease forwards;
            z-index: 30;
        }

        @keyframes healSparkle {
            0% { opacity: 0; transform: translateX(-50%) translateY(5px) scale(0.5); }
            50% { opacity: 1; transform: translateX(-50%) translateY(0) scale(1.2); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-15px) scale(0.8); }
        }

        .player-sprite-container.damaged .knight-image {
            animation: knightDamaged 0.25s ease;
        }

        @keyframes knightDamaged {
            0%, 100% { transform: translateX(0); filter: brightness(1) drop-shadow(2px 2px 2px rgba(0,0,0,0.5)); }
            25% { transform: translateX(-4px); filter: brightness(2) drop-shadow(2px 2px 2px rgba(0,0,0,0.5)); }
            75% { transform: translateX(4px); filter: brightness(2) drop-shadow(2px 2px 2px rgba(0,0,0,0.5)); }
        }

        .player-weapon {
            position: absolute;
            bottom: 20px;
            right: -5px;
            font-size: 14px;
            filter: drop-shadow(1px 1px 0 #000);
            z-index: 25;
        }

        .player-info {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 70px;
        }

        .player-name {
            font-size: 22px;
            color: var(--cream);
            text-shadow: 1px 1px 0 #000;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-health-bar {
            width: 58px;
            height: 7px;
            background: #1a1a2a;
            border: 1px solid #3a3a4a;
            border-radius: 2px;
            margin: 2px auto 0;
            overflow: hidden;
        }

        .player-health-fill {
            height: 100%;
            background: var(--health-green);
            transition: width 0.2s ease, background 0.2s ease;
        }

        .player-health-fill.medium { background: #FFC0A7; }
        .player-health-fill.low { background: #E2675D; }

        /* Floating Text */
        .floating-text {
            position: absolute;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            pointer-events: none;
            z-index: 200;
            animation: floatUp 0.8s ease forwards;
            text-shadow: 2px 2px 0 #000;
        }

        .floating-text.damage { color: var(--health-red); }
        .floating-text.heal { color: var(--health-green); }
        .floating-text.crit { font-size: 18px; color: var(--gold); }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-40px) scale(1.2); }
        }

        /* Status Bar */
        .status-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 32px;
            background: rgba(26, 21, 32, 0.92);
            padding: 14px 40px;
            border-radius: 10px;
            border: 4px solid var(--lavender);
            z-index: 50;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }

        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .status-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
            color: var(--lavender);
            text-transform: uppercase;
        }

        .status-value {
            font-family: 'Press Start 2P', cursive;
            font-size: 15px;
            color: var(--cream);
        }

        .status-value.timer { color: var(--gold); }
        .status-value.players { color: var(--rose); }

        /* Battle Log - Larger, bottom right */
        .battle-log {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 220px;
            background: rgba(26, 21, 32, 0.92);
            border: 3px solid var(--lavender);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            z-index: 55;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }

        .battle-log-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            color: var(--rose);
            margin-bottom: 12px;
            text-transform: uppercase;
        }

        .battle-log-entry {
            font-size: 16px;
            color: var(--cream);
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(154, 130, 169, 0.2);
        }

        .battle-log::-webkit-scrollbar { width: 6px; }
        .battle-log::-webkit-scrollbar-track { background: var(--bg-dark); }
        .battle-log::-webkit-scrollbar-thumb { background: var(--lavender); border-radius: 3px; }

        /* Phase Overlays */
        .phase-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(26, 21, 32, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
        }

        .phase-overlay.active { opacity: 1; visibility: visible; }

        .phase-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 66px;
            color: var(--rose);
            text-shadow: 6px 6px 0 var(--lavender);
            margin-bottom: 30px;
            text-align: center;
        }

        .phase-subtitle {
            font-family: 'VT323', monospace;
            font-size: 45px;
            color: var(--cream);
            margin-bottom: 18px;
        }

        .phase-timer {
            font-family: 'Press Start 2P', cursive;
            padding-top: 20px;
            font-size: 97px;
            color: var(--gold);
            text-shadow: 5px 5px 0 var(--bg-medium);
        }

        .phase-instruction {
            font-family: 'VT323', monospace;
            font-size: 38px;
            color: var(--lavender);
            margin-top: 30px;
        }
        
        .lobby-tip {
            font-family: 'VT323', monospace;
            font-size: 28px;
            color: var(--lavender);
            margin-top: 10px;
            opacity: 0.8;
        }
        
        .lobby-content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .lobby-player-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
        }
        
        /* Lobby knight sprites - similar to battle but no health bar */
        .lobby-knight {
            position: absolute;
            width: 61px;
            height: 76px;
            z-index: 25;
            pointer-events: none;
        }
        
        .lobby-knight .knight-image {
            width: 61px;
            height: 61px;
            /*image-rendering: pixelated;*/
        }
        
        .lobby-knight .lobby-player-name {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            color: var(--cream);
            text-shadow: 1px 1px 0 var(--bg-dark);
            white-space: nowrap;
        }
        
        /* Lobby speech bubble for taunts */
        .lobby-knight .lobby-speech-bubble {
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--cream);
            color: var(--bg-dark);
            padding: 4px 8px;
            border-radius: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            white-space: nowrap;
            z-index: 100;
            animation: lobbySpeechPop 2.5s ease-out forwards;
        }
        
        .lobby-knight .lobby-speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid var(--cream);
        }
        
        @keyframes lobbySpeechPop {
            0% { opacity: 0; transform: translateX(-50%) translateY(5px) scale(0.8); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0) scale(1.1); }
            20% { transform: translateX(-50%) translateY(0) scale(1); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px) scale(1); }
        }
        
        /* Lobby hit effect - bounce and flash */
        .lobby-knight.lobby-hit .knight-image {
            animation: lobbyHitBounce 0.4s ease-out;
        }
        
        @keyframes lobbyHitBounce {
            0% { transform: scale(1); filter: brightness(1); }
            15% { transform: scale(1.2) translateY(-10px); filter: brightness(2) sepia(1) saturate(5) hue-rotate(-20deg); }
            30% { transform: scale(0.9) translateY(5px); filter: brightness(1.5); }
            50% { transform: scale(1.1) translateY(-5px); filter: brightness(1.2); }
            70% { transform: scale(0.95); filter: brightness(1.1); }
            100% { transform: scale(1); filter: brightness(1); }
        }
        
        /* Lobby projectile */
        .lobby-projectile {
            position: absolute;
            width: 14px;
            height: 22px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 8;
            pointer-events: none;
            /*image-rendering: pixelated;*/
            filter: drop-shadow(0 0 4px rgba(250, 230, 155, 0.6));
        }

        .player-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            max-width: 900px;
            margin-top: 27px;
        }

        .player-list-item {
            background: var(--bg-medium);
            padding: 8px 18px;
            border-radius: 8px;
            border: 3px solid var(--rose);
            font-size: 21px;
            color: var(--cream);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Rage mode Transition Overlay */
        .phase-transition-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 107, 53, 0);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 450;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease, background 0.3s ease;
        }

        .phase-transition-overlay.active {
            opacity: 1;
            visibility: visible;
            background: rgba(255, 107, 53, 0.3);
            animation: phase2Flash 1s ease;
        }

        @keyframes phase2Flash {
            0% { background: rgba(255, 107, 53, 0); }
            30% { background: rgba(255, 107, 53, 0.6); }
            100% { background: rgba(255, 107, 53, 0.1); }
        }

        .phase-transition-overlay .phase-title {
            color: var(--rage-orange);
            text-shadow: 6px 6px 0 var(--bg-dark), 0 0 45px var(--rage-orange);
            animation: phase2TextPulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes phase2TextPulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        /* Result Screens */
        .result-screen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 600;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
        }

        .result-screen.active { opacity: 1; visibility: visible; }
        .result-screen.victory { background: linear-gradient(180deg, rgba(162, 207, 168, 0.85) 0%, rgba(26, 21, 32, 0.95) 100%); }
        .result-screen.defeat { background: linear-gradient(180deg, rgba(232, 92, 92, 0.85) 0%, rgba(26, 21, 32, 0.95) 100%); }

        .result-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 60px;
            margin-bottom: 36px;
            text-shadow: 6px 6px 0 var(--bg-dark);
        }

        .result-screen.victory .result-title { color: var(--gold); }
        .result-screen.defeat .result-title { color: var(--health-red); }

        .mvp-section {
            background: rgba(46, 39, 51, 0.92);
            padding: 26px 54px;
            border-radius: 14px;
            border: 5px solid var(--gold);
            text-align: center;
        }

        .mvp-label { font-family: 'Press Start 2P', cursive; font-size: 14px; color: var(--gold); margin-bottom: 12px; }
        .mvp-name { font-family: 'Press Start 2P', cursive; font-size: 29px; color: var(--cream); margin-bottom: 18px; }
        .mvp-stats { display: flex; gap: 36px; justify-content: center; }
        .mvp-stat { text-align: center; }
        .mvp-stat-label { font-size: 14px; color: var(--lavender); margin-bottom: 4px; }
        .mvp-stat-value { font-family: 'Press Start 2P', cursive; font-size: 22px; color: var(--cream); }

        .stats-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            margin-top: 36px;
            max-width: 1000px;
        }

        .stat-card {
            background: rgba(46, 39, 51, 0.8);
            padding: 12px;
            border-radius: 6px;
            border: 2px solid var(--lavender);
            text-align: center;
            width: 180px;
            flex-shrink: 0;
        }

        .stat-card-name { font-size: 14px; color: var(--rose); margin-bottom: 6px; }
        .stat-card-damage { font-family: 'Press Start 2P', cursive; font-size: 12px; color: var(--health-red); }
        .stat-card-healing { font-family: 'Press Start 2P', cursive; font-size: 12px; color: var(--health-green); }
        
        /* Version Label */
        .version-label {
            position: absolute;
            bottom: 10px;
            left: 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--lavender);
            opacity: 0.6;
            z-index: 500;
        }
    </style>
</head>
<body>
    <div class="game-container" id="game">
        <div class="cave-background"></div>
        <div class="cave-overlay"></div>
        <div class="cave-corner-overlay"></div>

        <div class="game-title">BOSS BATTLE</div>

        <div class="boss-area" id="boss-area">
            <div class="boss-health-container">
                <div class="boss-name" id="boss-name">BATSY THE BEAST</div>
                <div class="boss-health-bar">
                    <div class="boss-health-fill" id="boss-health-fill" style="width: 100%;"></div>
                    <div class="boss-health-text" id="boss-health-text">1000 / 1000</div>
                </div>
                <div class="boss-phase" id="boss-phase">GROUND SLAM</div>
            </div>
            <div class="boss-sprite-container">
                <div class="boss-sprite" id="boss-sprite">
                    <img class="boss-image" id="boss-image" src="images/batsy_static.PNG">
                </div>
            </div>
        </div>

        <div id="projectiles-container" style="position:absolute;top:0;left:0;right:0;bottom:0;z-index:40;pointer-events:none;"></div>

        <div class="player-area" id="player-area"></div>

        <div id="floating-text-container" style="position:absolute;top:0;left:0;right:0;bottom:0;z-index:200;pointer-events:none;"></div>

        <div class="battle-log" id="battle-log">
            <div class="battle-log-title">Battle Log</div>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <span class="status-label">Players</span>
                <span class="status-value players" id="player-count">0 / 30</span>
            </div>
            <div class="status-item">
                <span class="status-label">Alive</span>
                <span class="status-value" id="alive-count">0</span>
            </div>
            <div class="status-item">
                <span class="status-label">Time</span>
                <span class="status-value timer" id="game-timer">0:00</span>
            </div>
            <div class="status-item">
                <span class="status-label">Total DMG</span>
                <span class="status-value" id="total-damage">0</span>
            </div>
        </div>

        <!-- Phase Overlays -->
        <div class="phase-overlay active" id="lobby-overlay">
            <div class="lobby-content">
                <div class="phase-title">BOSS BATTLE</div>
                <div class="phase-subtitle">Type <span style="color: var(--rose);">!play</span> in chat to join!</div>
                <div class="phase-timer" id="lobby-timer">60</div>
                <div class="phase-instruction">Waiting for players... (<span id="lobby-player-count">0</span>/25)</div>
                <div class="lobby-tip">Try <span style="color: var(--rose);">!attack @player</span> or <span style="color: var(--rose);">!taunt message</span></div>
            </div>
            <!-- Lobby arena for knights to roam -->
            <div class="lobby-player-area" id="lobby-player-area"></div>
        </div>

        <div class="phase-overlay" id="boss-intro-overlay">
            <div class="phase-title" id="boss-intro-name">BATSY THE BEAST</div>
            <div class="phase-subtitle">has awoken!</div>
            <div style="background: rgba(46, 39, 51, 0.9); padding: 25px 40px; border-radius: 12px; border: 3px solid var(--lavender); max-width: 800px; text-align: left; margin-top: 20px;">
                <div style="font-size: 28px; color: var(--rose); line-height: 1.7; margin-bottom: 15px; text-align: center;">
                    Work together to kill Batsy the Beast. The player to collectively earn the most points through attacking and healing will be crowned winner.
                </div>
                <div style="font-size: 24px; color: var(--cream); line-height: 1.8;">
                    <div style="margin-bottom: 10px;"><span style="color: var(--rose);">!attack</span> — Cause damage to Batsy</div>
                    <div style="margin-bottom: 10px;"><span style="color: var(--rose);">!heal</span> — Heal yourself or tag another player to heal them</div>
                    <div style="margin-bottom: 10px;"><span style="color: var(--rose);">!shield</span> — Block all damage (you cannot attack or heal during this period)</div>
                    <div style="margin-bottom: 10px;"><span style="color: var(--rose);">!taunt 'message'</span> — Taunt Batsy to increase your next attack (18 char)</div>
                    <div style="margin-bottom: 10px;"><span style="color: var(--rose);">!revive @player</span> — Revive a fallen teammate (15 seconds)</div>
                    <div style="margin-top: 15px; font-size: 22px; color: var(--lavender); text-align: center;">All commands have cooldowns, so no need to spam.</div>
                </div>
            </div>
            <div class="phase-timer" id="intro-timer" style="margin-top: 25px;">20</div>
            <div style="font-size: 26px; color: var(--lavender); margin-top: 5px;">Battle begins in...</div>
        </div>

        <!-- Rage Warning Overlay -->
        <div class="phase-transition-overlay" id="rage-overlay">
            <div class="phase-title" style="color: var(--rage-orange); text-shadow: 6px 6px 0 var(--bg-dark), 0 0 45px var(--rage-orange);">BATSY IS ENRAGED!</div>
        </div>

        <!-- Result Screens -->
        <div class="result-screen victory" id="victory-screen">
            <div class="result-title">VICTORY!</div>
            <div class="mvp-section">
                <div class="mvp-label">‧₊˚. CHAMPION BATSY SLAYER .˚₊‧</div>
                <div class="mvp-name" id="mvp-name">PlayerName</div>
                <div class="mvp-stats">
                    <div class="mvp-stat">
                        <div class="mvp-stat-label">Damage</div>
                        <div class="mvp-stat-value" id="mvp-damage">0</div>
                    </div>
                    <div class="mvp-stat">
                        <div class="mvp-stat-label">Healing</div>
                        <div class="mvp-stat-value" id="mvp-healing">0</div>
                    </div>
                </div>
            </div>
            <div class="stats-grid" id="victory-stats"></div>
        </div>

        <div class="result-screen defeat" id="defeat-screen">
            <div class="result-title">DEFEAT</div>
            <div class="phase-subtitle" style="margin-bottom: 15px;">Batsy remains victorious...</div>
            <div class="mvp-section" style="border-color: var(--lavender);">
                <div class="mvp-label" style="color: var(--lavender);">BEST EFFORT</div>
                <div class="mvp-name" id="defeat-mvp-name">PlayerName</div>
                <div class="mvp-stats">
                    <div class="mvp-stat">
                        <div class="mvp-stat-label">Boss HP Left</div>
                        <div class="mvp-stat-value" id="defeat-boss-hp">0</div>
                    </div>
                    <div class="mvp-stat">
                        <div class="mvp-stat-label">Team Damage</div>
                        <div class="mvp-stat-value" id="defeat-team-damage">0</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Version Label -->
        <div class="version-label">Version 6.6.6</div>
        
        <!-- Music -->
        <audio id="music-lobby" src="audio/Pixel-Fantasia.mp3" preload="auto" loop></audio>
        <audio id="music-battle" src="audio/Halloween-Retro.mp3" preload="auto" loop></audio>
    </div>

    <script>

                // Knight animation frames (5 frames)
        const KNIGHT_FRAMES = {
            1: 'images/knight_run_1.PNG',
            2: 'images/knight_run_2.PNG',
            3: 'images/knight_run_3.PNG',
            4: 'images/knight_run_4.PNG',
            5: 'images/knight_run_5.PNG'
        };

        // Revived player animation frames (5 frames - ghost/skeleton style)
        const REVIVED_FRAMES = {
            1: 'images/revived_player_1.PNG',
            2: 'images/revived_player_2.PNG',
            3: 'images/revived_player_3.PNG',
            4: 'images/revived_player_4.PNG',
            5: 'images/revived_player_5.PNG'
        };

                // ===== BATSY ANIMATION FRAMES =====
        const BATSY_FRAMES = {
            'static': 'images/batsy_static.PNG',
            'preslam': 'images/batsy_preslam.PNG',
            'slam': 'images/batsy_slam.PNG',
            'death': 'images/batsy_death.PNG'
        };
        
        // Projectile images per weapon
        const PROJECTILE_IMAGES = {
            bow: 'images/player_arrow_bow.PNG',
            bossLarge: 'images/projectile_large.PNG',
            bossSmall: 'images/projectile_small.PNG',
        };

        // Falling projectile images
        const FALL_PROJECTILE_IMAGES = {
            rockSlideSmall: 'images/projectile_rain_small.PNG',
            rockSlideLarge: 'images/projectile_rain_large.PNG'
        };
        
        // Hit marker images
        const HIT_MARKERS = {
            damage: 'images/hit_marker_damage.PNG',
            death: 'images/hit_marker_death.PNG',
            shield: 'images/hit_marker_shield.PNG'
        };
        
        // Death state image  
        const DEATH_STATE_IMG = 'images/death_state.PNG'

        // ===== GAME CONFIGURATION =====
        const CONFIG = {
            channel: 'geor0se',
            maxPlayers: 25,
            lobbyDuration: 60,
            bossIntroDuration: 30,
            
            // Boss Stats (single phase)
            bossHealth: 1000,
            attackInterval: 3000,
            hitChance: 0.5,
            projectilesMin: 5,
            projectilesMax: 9,
            
            // Rage Attack Config (triggers randomly every 5-7 slams)
            rageSlamMin: 5,
            rageSlamMax: 7,
            rageProjectilesMin: 10,
            rageProjectilesMax: 14,
            rageHitChance: 0.65,
            rageDamageMultiplier: 1.25,
            
            bossBaseDamage: 12,
            
            playerMaxHealth: 100,
            attackCooldown: 3000,
            healCooldown: 5000,
            healAmount: 10,
            
            maxDamageMultiplier: 1.5,
            minDamageMultiplier: 0.7,
            
            playerMoveSpeed: 4.0,
            playerMoveInterval: 50,
            playAreaWidth: 1760,
            playAreaHeight: 540,
            playerAreaTop: 380,
            
            playerHitboxWidth: 51,
            playerHitboxHeight: 61,
            projectileSize: 24,
            rageProjectileSize: 32,
            
            // Bow weapon stats
            bowDamage: 10,
            bowCritChance: 0.15,
            
            // Restricted zones (areas players cannot enter) - in SCREEN coordinates
            // Triangular corner zones approximated with stacked rectangles
            restrictedZones: [
                // Zone 1: Right side rock formation (original)
                { x1: 1279, y1: 398, x2: 1477, y2: 533 },
                // Zone 2: Left side rock formation (original)
                { x1: 113, y1: 501, x2: 391, y2: 674 },
                
                // LEFT TRIANGLE - stacked rectangles from bottom-left corner
                // Bottom slice (widest)
                { x1: 0, y1: 1000, x2: 480, y2: 1080 },
                { x1: 0, y1: 920, x2: 400, y2: 1000 },
                { x1: 0, y1: 840, x2: 320, y2: 920 },
                { x1: 0, y1: 760, x2: 240, y2: 840 },
                { x1: 0, y1: 680, x2: 160, y2: 760 },
                { x1: 0, y1: 600, x2: 80, y2: 680 },
                
                // RIGHT TRIANGLE - stacked rectangles from bottom-right corner
                // Bottom slice (widest)
                { x1: 1440, y1: 1000, x2: 1920, y2: 1080 },
                { x1: 1520, y1: 920, x2: 1920, y2: 1000 },
                { x1: 1600, y1: 840, x2: 1920, y2: 920 },
                { x1: 1680, y1: 760, x2: 1920, y2: 840 },
                { x1: 1760, y1: 680, x2: 1920, y2: 760 },
                { x1: 1840, y1: 600, x2: 1920, y2: 680 }
            ],
            playerAreaOffsetX: 80,
            playerAreaOffsetY: 380
        };

        let gameState = {
            phase: 'idle',
            players: {},
            lobbyPlayers: {},
            boss: { health: CONFIG.bossHealth, maxHealth: CONFIG.bossHealth },
            totalDamage: 0,
            gameStartTime: null,
            timers: {},
            moveInterval: null,
            lobbyMoveInterval: null,
            activeProjectiles: [],
            animationFrame: 1,
            animationInterval: null,
            lobbyAnimationFrame: 1,
            lobbyAnimationInterval: null,
            slamCount: 0,
            nextRageSlam: 0,
            isRageAttack: false
        };
        
        // Calculate next rage slam (random between min-max slams)
        function calculateNextRageSlam() {
            return CONFIG.rageSlamMin + Math.floor(Math.random() * (CONFIG.rageSlamMax - CONFIG.rageSlamMin + 1));
        }

        // Audio
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;
        function initAudio() { if (!audioCtx) audioCtx = new AudioContext(); }
        
        // ===== MUSIC SYSTEM =====
        const music = {
            lobby: null,
            battle: null,
            fadeInterval: null,
            volume: 0.2 // Master music volume
        };
        
        function initMusic() {
            if (!music.lobby) music.lobby = document.getElementById('music-lobby');
            if (!music.battle) music.battle = document.getElementById('music-battle');
        }
        
        function playMusic(track) {
            initMusic();
            const audio = track === 'lobby' ? music.lobby : music.battle;
            const other = track === 'lobby' ? music.battle : music.lobby;
            if (!audio) return;
            
            // Clear any ongoing fade
            if (music.fadeInterval) {
                clearInterval(music.fadeInterval);
                music.fadeInterval = null;
            }
            
            // Fade out the other track if playing
            if (other && !other.paused) {
                fadeOutMusic(other, 800);
            }
            
            // Start new track
            audio.volume = 0;
            audio.currentTime = 0;
            audio.play().catch(() => {}); // Catch autoplay restrictions silently
            
            // Fade in
            let vol = 0;
            const fadeIn = setInterval(() => {
                vol += 0.02;
                if (vol >= music.volume) {
                    vol = music.volume;
                    clearInterval(fadeIn);
                }
                audio.volume = vol;
            }, 30);
        }
        
        function fadeOutMusic(audio, duration) {
            if (!audio || audio.paused) return;
            const startVol = audio.volume;
            const step = startVol / (duration / 30);
            const fade = setInterval(() => {
                audio.volume = Math.max(0, audio.volume - step);
                if (audio.volume <= 0) {
                    clearInterval(fade);
                    audio.pause();
                    audio.currentTime = 0;
                }
            }, 30);
        }
        
        function stopAllMusic() {
            initMusic();
            if (music.fadeInterval) {
                clearInterval(music.fadeInterval);
                music.fadeInterval = null;
            }
            [music.lobby, music.battle].forEach(audio => {
                if (audio) fadeOutMusic(audio, 1500);
            });
        }
        // Boss animation frame switcher
        function setBossFrame(frame) {
            if (elements.bossImage && BATSY_FRAMES[frame]) {
                elements.bossImage.src = BATSY_FRAMES[frame];
            }
        }
        
        // Player animation system
        function startPlayerAnimation() {
            if (gameState.animationInterval) return;
            gameState.animationFrame = 1;
            gameState.animationInterval = setInterval(() => {
                gameState.animationFrame = (gameState.animationFrame % 5) + 1;
                updateAllPlayerFrames();
            }, 120); // 120ms per frame = ~8 FPS animation
        }
        
        function stopPlayerAnimation() {
            if (gameState.animationInterval) {
                clearInterval(gameState.animationInterval);
                gameState.animationInterval = null;
            }
            gameState.animationFrame = 1;
            updateAllPlayerFrames();
        }
        
        function updateAllPlayerFrames() {
            document.querySelectorAll('.player-sprite-container').forEach(el => {
                const username = el.dataset.username;
                const player = gameState.players[username];
                if (!player || !player.alive) return;
                
                const frame = gameState.animationFrame || 1;
                
                // Update knight body — use revived frames if applicable
                const knightImg = el.querySelector('.knight-image');
                if (knightImg) {
                    if (player.revived) {
                        knightImg.src = REVIVED_FRAMES[frame] || REVIVED_FRAMES[1];
                    } else if (KNIGHT_FRAMES[frame]) {
                        knightImg.src = KNIGHT_FRAMES[frame];
                    }
                }
            });
        }
        
        // Check if a player position collides with any restricted zone
        function isInRestrictedZone(playerX, playerY) {
            // Convert player-area coordinates to screen coordinates
            const screenX = CONFIG.playerAreaOffsetX + playerX;
            const screenY = CONFIG.playerAreaOffsetY + playerY;
            
            // Player hitbox (approximate center point with some padding)
            const hitboxPadding = 20;
            const pLeft = screenX;
            const pRight = screenX + CONFIG.playerHitboxWidth;
            const pTop = screenY;
            const pBottom = screenY + CONFIG.playerHitboxHeight;
            
            for (const zone of CONFIG.restrictedZones) {
                // Check for rectangle intersection
                if (pRight > zone.x1 && pLeft < zone.x2 && 
                    pBottom > zone.y1 && pTop < zone.y2) {
                    return true;
                }
            }
            return false;
        }
        
        // Get valid spawn position (both X and Y checked together)
        function getValidSpawnPosition() {
            let x, y, attempts = 0;
            do {
                x = 80 + Math.random() * (CONFIG.playAreaWidth - 160);
                y = 80 + Math.random() * (CONFIG.playAreaHeight - 160);
                attempts++;
            } while (isInRestrictedZone(x, y) && attempts < 50);
            return { x, y };
        }
        
        function playSound(type) {
            if (!audioCtx) return;
            
            // Helper to create 8-bit style sounds with multiple oscillators
            function createTone(freq, duration, waveType, volume, freqEnd) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = waveType;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                if (freqEnd) osc.frequency.exponentialRampToValueAtTime(freqEnd, audioCtx.currentTime + duration);
                gain.gain.setValueAtTime(volume, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            }
            
            switch(type) {
                case 'attack':
                    // 8-bit laser/sword swing - descending arpeggio
                    createTone(880, 0.05, 'square', 0.15);
                    setTimeout(() => createTone(660, 0.05, 'square', 0.12), 30);
                    setTimeout(() => createTone(440, 0.08, 'square', 0.1), 60);
                    break;
                    
                case 'heal':
                    // Rising magical chime - ascending notes
                    createTone(523, 0.1, 'sine', 0.12);
                    setTimeout(() => createTone(659, 0.1, 'sine', 0.12), 80);
                    setTimeout(() => createTone(784, 0.15, 'sine', 0.1), 160);
                    setTimeout(() => createTone(1047, 0.2, 'sine', 0.08), 240);
                    break;
                    
                case 'slam':
                    // Heavy impact - low rumble with punch
                    createTone(60, 0.3, 'sawtooth', 0.35, 25);
                    createTone(120, 0.15, 'square', 0.2, 40);
                    setTimeout(() => createTone(80, 0.2, 'triangle', 0.15, 30), 50);
                    break;
                    
                case 'frenzy':
                    // Aggressive rapid fire - intense 8-bit
                    createTone(200, 0.08, 'square', 0.2, 80);
                    setTimeout(() => createTone(250, 0.08, 'square', 0.18, 100), 40);
                    setTimeout(() => createTone(180, 0.1, 'sawtooth', 0.15, 60), 80);
                    break;
                    
                case 'hit':
                    // Player taking damage - sharp impact
                    createTone(200, 0.08, 'square', 0.2, 50);
                    createTone(100, 0.1, 'sawtooth', 0.15, 30);
                    break;
                    
                case 'playerHit':
                    // Boss taking damage - satisfying crunch
                    createTone(600, 0.06, 'square', 0.18, 200);
                    setTimeout(() => createTone(400, 0.08, 'sawtooth', 0.12, 150), 40);
                    break;
                    
                case 'death':
                    // Player death - dramatic descending
                    createTone(400, 0.15, 'square', 0.2, 100);
                    setTimeout(() => createTone(300, 0.15, 'square', 0.18, 80), 100);
                    setTimeout(() => createTone(200, 0.2, 'sawtooth', 0.15, 50), 200);
                    setTimeout(() => createTone(100, 0.3, 'sawtooth', 0.12, 30), 300);
                    break;
                    
                case 'rage':
                    // Epic rage attack warning - dramatic warning
                    for (let i = 0; i < 4; i++) {
                        setTimeout(() => {
                            createTone(80 + i * 20, 0.25, 'sawtooth', 0.3 - i * 0.05, 40);
                            createTone(160 + i * 40, 0.2, 'square', 0.2 - i * 0.03, 80);
                        }, i * 100);
                    }
                    // Final impact
                    setTimeout(() => {
                        createTone(50, 0.4, 'sawtooth', 0.35, 25);
                        createTone(100, 0.3, 'square', 0.25, 50);
                    }, 400);
                    break;
                    
                case 'roar':
                    // Beast roar - deep guttural growl that swells
                    // Core rumbling growl (sustained low frequency)
                    createTone(45, 0.9, 'sawtooth', 0.35, 30);
                    createTone(60, 0.85, 'sawtooth', 0.3, 35);
                    createTone(90, 0.8, 'square', 0.2, 50);
                    
                    // Growl modulation - adds texture
                    setTimeout(() => {
                        createTone(50, 0.6, 'sawtooth', 0.28, 40);
                        createTone(75, 0.5, 'square', 0.18, 55);
                    }, 150);
                    
                    // Swell in the middle
                    setTimeout(() => {
                        createTone(55, 0.5, 'sawtooth', 0.32, 35);
                        createTone(80, 0.45, 'sawtooth', 0.25, 45);
                        createTone(110, 0.4, 'square', 0.15, 70);
                    }, 350);
                    
                    // Peak growl
                    setTimeout(() => {
                        createTone(50, 0.4, 'sawtooth', 0.3, 30);
                        createTone(70, 0.35, 'sawtooth', 0.25, 40);
                    }, 600);
                    
                    // Tail off
                    setTimeout(() => {
                        createTone(40, 0.3, 'sawtooth', 0.2, 25);
                    }, 800);
                    break;
                    
                case 'bossDeath':
                    // Deep dramatic death rumble - the beast falls
                    createTone(80, 0.6, 'sawtooth', 0.35, 20);
                    createTone(60, 0.5, 'sawtooth', 0.3, 15);
                    createTone(120, 0.4, 'square', 0.2, 30);
                    setTimeout(() => {
                        createTone(50, 0.8, 'sawtooth', 0.3, 10);
                        createTone(100, 0.5, 'square', 0.15, 25);
                    }, 300);
                    // Final low thud
                    setTimeout(() => {
                        createTone(35, 1.0, 'sawtooth', 0.35, 8);
                        createTone(70, 0.6, 'triangle', 0.15, 15);
                    }, 800);
                    break;
                    
                case 'victory':
                    // Triumphant fanfare
                    const victoryNotes = [523, 659, 784, 1047, 784, 1047];
                    victoryNotes.forEach((freq, i) => {
                        setTimeout(() => createTone(freq, 0.2, 'square', 0.15), i * 120);
                    });
                    break;
                    
                case 'revive':
                    // Ethereal rising chime - mystical resurrection
                    createTone(330, 0.15, 'sine', 0.12);
                    setTimeout(() => createTone(440, 0.15, 'sine', 0.12), 100);
                    setTimeout(() => createTone(554, 0.15, 'sine', 0.12), 200);
                    setTimeout(() => createTone(659, 0.15, 'sine', 0.1), 300);
                    setTimeout(() => createTone(880, 0.25, 'sine', 0.1), 400);
                    break;
                    
                case 'defeat':
                    // Sad game over
                    const defeatNotes = [400, 350, 300, 250, 200];
                    defeatNotes.forEach((freq, i) => {
                        setTimeout(() => createTone(freq, 0.25, 'sawtooth', 0.2 - i * 0.03, freq * 0.5), i * 200);
                    });
                    break;
            }
        }

        const elements = {
            game: document.getElementById('game'),
            playerArea: document.getElementById('player-area'),
            playerCount: document.getElementById('player-count'),
            aliveCount: document.getElementById('alive-count'),
            gameTimer: document.getElementById('game-timer'),
            totalDamage: document.getElementById('total-damage'),
            bossHealthFill: document.getElementById('boss-health-fill'),
            bossHealthText: document.getElementById('boss-health-text'),
            bossPhase: document.getElementById('boss-phase'),
            bossSprite: document.getElementById('boss-sprite'),
            bossImage: document.getElementById('boss-image'),
            lobbyOverlay: document.getElementById('lobby-overlay'),
            lobbyTimer: document.getElementById('lobby-timer'),
            lobbyPlayerArea: document.getElementById('lobby-player-area'),
            lobbyPlayerCount: document.getElementById('lobby-player-count'),
            bossIntroOverlay: document.getElementById('boss-intro-overlay'),
            rageOverlay: document.getElementById('rage-overlay'),
            victoryScreen: document.getElementById('victory-screen'),
            defeatScreen: document.getElementById('defeat-screen'),
            battleLog: document.getElementById('battle-log'),
            floatingTextContainer: document.getElementById('floating-text-container'),
            projectilesContainer: document.getElementById('projectiles-container')
        };

        function getBossCenter() {
            const bossRect = elements.bossImage.getBoundingClientRect();
            const gameRect = elements.game.getBoundingClientRect();
            return {
                x: bossRect.left - gameRect.left + bossRect.width / 2,
                y: bossRect.top - gameRect.top + bossRect.height / 2
            };
        }

        // Twitch
        const client = new tmi.Client({ channels: ['geor0se'] });
        client.connect().then(() => addBattleLog('System', 'Connected to Twitch!', 'system')).catch(err => {
            console.error('Twitch connection error:', err);
            addBattleLog('System', 'Connection failed - check console', 'system');
        });

        client.on('message', (channel, tags, message, self) => {
            if (self) return;
            const isMod = tags.mod || tags.badges?.broadcaster === '1';
            handleCommand(tags['display-name'] || tags.username, message.toLowerCase().trim(), isMod);
        });

        function handleCommand(username, message, isMod = false) {
            switch (gameState.phase) {
                case 'lobby':
                    if (message === '!play') joinGame(username);
                    else if (message.startsWith('!attack @')) lobbyAttack(username, message);
                    else if (message.startsWith('!taunt ')) lobbyTaunt(username, message);
                    break;
                case 'battle':
                    if (message === '!attack') playerAttack(username);
                    else if (message.startsWith('!heal')) playerHeal(username, message.split(' ')[1]);
                    else if (message === '!shield') playerShield(username);
                    else if (message.startsWith('!taunt')) playerTaunt(username, message);
                    else if (message.startsWith('!revive')) playerRevive(username, message.split(' ')[1]);
                    break;
            }
            if ((message === '!bossfight' || message === '!startboss') && isMod) startLobby();
            if (message === '!restart' && isMod) restartGame();
        }

        function startPlayerMovement() {
            if (gameState.moveInterval) clearInterval(gameState.moveInterval);
            gameState.moveInterval = setInterval(() => {
                Object.values(gameState.players).forEach(player => {
                    if (!player.alive) return;
                    
                    // More random direction changes for variety
                    if (Math.random() < 0.04) player.direction = Math.random() * Math.PI * 2;
                    // Occasionally reverse direction
                    if (Math.random() < 0.02) player.direction += Math.PI;
                    
                    let newX = player.x + Math.cos(player.direction) * CONFIG.playerMoveSpeed;
                    let newY = player.y + Math.sin(player.direction) * CONFIG.playerMoveSpeed;
                    
                    const margin = 30;
                    if (newX < margin || newX > CONFIG.playAreaWidth - margin) {
                        player.direction = Math.PI - player.direction + (Math.random() - 0.5) * 0.5;
                        newX = Math.max(margin, Math.min(CONFIG.playAreaWidth - margin, newX));
                    }
                    if (newY < margin || newY > CONFIG.playAreaHeight - margin) {
                        player.direction = -player.direction + (Math.random() - 0.5) * 0.5;
                        newY = Math.max(margin, Math.min(CONFIG.playAreaHeight - margin, newY));
                    }
                    
                    // Check restricted zones collision
                    if (isInRestrictedZone(newX, newY)) {
                        // Bounce off the restricted zone
                        player.direction += Math.PI + (Math.random() - 0.5) * 0.5;
                        newX = player.x;
                        newY = player.y;
                    }
                    
                    player.x = newX;
                    player.y = newY;
                    
                    const el = document.querySelector(`[data-username="${player.username}"]`);
                    if (el) {
                        el.style.left = player.x + 'px';
                        el.style.top = player.y + 'px';
                        const img = el.querySelector('.knight-image');
                        if (img) img.style.transform = Math.cos(player.direction) < 0 ? 'scaleX(-1)' : 'scaleX(1)';
                    }
                });
            }, CONFIG.playerMoveInterval);
        }

        function stopPlayerMovement() {
            if (gameState.moveInterval) { clearInterval(gameState.moveInterval); gameState.moveInterval = null; }
        }
        
        function stopLobbyMovement() {
            if (gameState.lobbyMoveInterval) { clearInterval(gameState.lobbyMoveInterval); gameState.lobbyMoveInterval = null; }
        }

        function startLobby() {
            if (gameState.phase !== 'idle') return;
            initAudio();
            gameState.phase = 'lobby';
            gameState.players = {};
            gameState.lobbyPlayers = {}; // Separate lobby player data
            gameState.totalDamage = 0;
            gameState.activeProjectiles = [];
            gameState.slamCount = 0;
            gameState.nextRageSlam = calculateNextRageSlam();
            gameState.isRageAttack = false;
            elements.game.classList.remove('rage-mode');
            resetBoss();
            updateUI();
            
            elements.lobbyOverlay.classList.add('active');
            elements.lobbyPlayerArea.innerHTML = '';
            elements.lobbyPlayerCount.textContent = '0';
            
            // Start lobby knight animation
            startLobbyAnimation();
            startLobbyMovement();
            
            // Start lobby music
            playMusic('lobby');
            
            let timeLeft = CONFIG.lobbyDuration;
            elements.lobbyTimer.textContent = timeLeft;
            
            gameState.timers.lobby = setInterval(() => {
                timeLeft--;
                elements.lobbyTimer.textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(gameState.timers.lobby);
                    Object.keys(gameState.players).length >= 1 ? startBossIntro() : (endGame('idle'), addBattleLog('System', 'Not enough players!', 'system'));
                }
            }, 1000);
            
            addBattleLog('System', 'Type !play to join!', 'system');
        }

        function startBossIntro() {
            gameState.phase = 'intro';
            
            // Clean up lobby systems
            stopLobbyMovement();
            stopLobbyAnimation();
            elements.lobbyPlayerArea.innerHTML = '';
            gameState.lobbyPlayers = {};
            
            elements.lobbyOverlay.classList.remove('active');
            elements.bossIntroOverlay.classList.add('active');
            renderPlayers();
            
            // Countdown timer for intro screen
            let introTimeLeft = CONFIG.bossIntroDuration;
            const introTimerEl = document.getElementById('intro-timer');
            if (introTimerEl) {
                introTimerEl.textContent = introTimeLeft;
            }
            
            gameState.timers.intro = setInterval(() => {
                introTimeLeft--;
                if (introTimerEl) {
                    introTimerEl.textContent = introTimeLeft;
                }
                // Begin fading out lobby music with 5 seconds left
                if (introTimeLeft === 5) {
                    initMusic();
                    if (music.lobby && !music.lobby.paused) {
                        fadeOutMusic(music.lobby, 5000);
                    }
                }
                if (introTimeLeft <= 0) {
                    clearInterval(gameState.timers.intro);
                    elements.bossIntroOverlay.classList.remove('active');
                    startBattle();
                }
            }, 1000);
        }

        function startBattle() {
            gameState.phase = 'battle';
            gameState.gameStartTime = Date.now();
            gameState.slamCount = 0;
            gameState.nextRageSlam = calculateNextRageSlam();
            startPlayerMovement();
            document.querySelectorAll('.player-sprite-container').forEach(el => el.classList.add('walking'));
            startPlayerAnimation();
            
            gameState.timers.bossAttack = setInterval(bossAttack, CONFIG.attackInterval);
            gameState.timers.gameTimer = setInterval(updateGameTimer, 1000);
            
            // Switch to battle music
            playMusic('battle');
            
            addBattleLog('System', 'BATTLE START!', 'system');
        }

        function triggerBossDeath() {
            // Stop the battle immediately — no more boss attacks or player movement
            gameState.phase = 'boss_death';
            Object.values(gameState.timers).forEach(t => clearInterval(t));
            gameState.timers = {};
            
            // Clean up active projectiles
            gameState.activeProjectiles.forEach(p => {
                if (p.element && p.element.parentNode) p.element.remove();
            });
            gameState.activeProjectiles = [];
            
            initAudio();
            playSound('bossDeath');
            
            // Begin fading out battle music
            stopAllMusic();
            
            addBattleLog('BATSY', 'has been SLAIN!', 'boss');
            
            // Screen shake on killing blow
            elements.game.classList.add('shaking');
            setTimeout(() => elements.game.classList.remove('shaking'), 300);
            
            // Phase 1: Violent shake (0 - 800ms)
            elements.bossSprite.classList.remove('damaged', 'slamming', 'frenzied');
            elements.bossSprite.classList.add('death-shake');
            
            // Phase 2: Collapse animation + swap to death image (800ms - 1800ms)
            setTimeout(() => {
                elements.bossSprite.classList.remove('death-shake');
                elements.bossSprite.classList.add('death-collapse');
                setBossFrame('death');
            }, 800);
            
            // Phase 3: Hold death pose (1800ms - 3500ms)
            setTimeout(() => {
                elements.bossSprite.classList.remove('death-collapse');
                elements.bossSprite.classList.add('death-final');
            }, 1800);
            
            // Phase 4: Transition to victory screen (3500ms)
            setTimeout(() => {
                endGame('victory');
            }, 3500);
        }

        function endGame(result) {
            gameState.phase = result;
            Object.values(gameState.timers).forEach(t => clearInterval(t));
            gameState.timers = {};
            stopPlayerMovement();
            stopLobbyMovement();
            stopLobbyAnimation();
            
            // Clean up active projectiles
            gameState.activeProjectiles.forEach(p => {
                if (p.element && p.element.parentNode) p.element.remove();
            });
            gameState.activeProjectiles = [];
            
            ['lobbyOverlay', 'bossIntroOverlay', 'rageOverlay'].forEach(o => elements[o].classList.remove('active'));
            elements.game.classList.remove('rage-mode');
            elements.lobbyPlayerArea.innerHTML = '';
            document.querySelectorAll('.player-sprite-container').forEach(el => el.classList.remove('walking'));
            stopPlayerAnimation();
            
            // Fade out music
            stopAllMusic();
            
            if (result === 'victory') showVictoryScreen();
            else if (result === 'defeat') showDefeatScreen();
        }
        
        function restartGame() {
            // Hide result screens
            elements.victoryScreen.classList.remove('active');
            elements.defeatScreen.classList.remove('active');
            
            // Reset boss sprite state
            elements.bossSprite.classList.remove('death-shake', 'death-collapse', 'death-final', 'damaged', 'slamming', 'frenzied');
            setBossFrame('static');
            
            // Clear battle log except header
            while (elements.battleLog.children.length > 1) {
                elements.battleLog.children[1].remove();
            }
            
            // Clear player area and projectiles
            elements.playerArea.innerHTML = '';
            elements.projectilesContainer.innerHTML = '';
            elements.floatingTextContainer.innerHTML = '';
            
            // Reset phase to allow startLobby
            gameState.phase = 'idle';
            
            // Start new lobby
            startLobby();
        }

        function joinGame(username) {
            if (gameState.players[username] || Object.keys(gameState.players).length >= CONFIG.maxPlayers) return;
            
            // Random spawn position for lobby (full screen, no restrictions)
            const lobbyX = 100 + Math.random() * 1720;
            const lobbyY = 200 + Math.random() * 700;
            
            // Create battle player data (for when battle starts)
            gameState.players[username] = {
                username,
                health: CONFIG.playerMaxHealth,
                maxHealth: CONFIG.playerMaxHealth,
                damage: 0,
                healing: 0,
                alive: true,
                revived: false,
                hasRevived: false,
                lastAttack: 0,
                lastHeal: 0,
                lastShield: 0,
                shielded: false,
                tauntBoost: false,
                ...getValidSpawnPosition(),
                direction: Math.random() * Math.PI * 2
            };
            
            // Create lobby player data (for lobby movement)
            gameState.lobbyPlayers[username] = {
                username,
                x: lobbyX,
                y: lobbyY,
                direction: Math.random() * Math.PI * 2
            };
            
            // Spawn lobby knight
            spawnLobbyKnight(username);
            
            // Update player count
            elements.lobbyPlayerCount.textContent = Object.keys(gameState.players).length;
            
            updateUI();
            addBattleLog(username, 'joined the battle!', 'join');
        }
        
        function spawnLobbyKnight(username) {
            const lobbyPlayer = gameState.lobbyPlayers[username];
            if (!lobbyPlayer) return;
            
            const knight = document.createElement('div');
            knight.className = 'lobby-knight';
            knight.dataset.lobbyUsername = username;
            knight.style.left = lobbyPlayer.x + 'px';
            knight.style.top = lobbyPlayer.y + 'px';
            
            const frame = gameState.lobbyAnimationFrame || 1;
            const knightSrc = KNIGHT_FRAMES[frame] || KNIGHT_FRAMES[1];
            
            knight.innerHTML = `
                <img class="knight-image" src="${knightSrc}" alt="Knight">
                <div class="lobby-player-name">${username}</div>
            `;
            
            elements.lobbyPlayerArea.appendChild(knight);
        }
        
        function startLobbyAnimation() {
            if (gameState.lobbyAnimationInterval) return;
            gameState.lobbyAnimationFrame = 1;
            gameState.lobbyAnimationInterval = setInterval(() => {
                gameState.lobbyAnimationFrame = (gameState.lobbyAnimationFrame % 5) + 1;
                updateLobbyKnightFrames();
            }, 120);
        }
        
        function stopLobbyAnimation() {
            if (gameState.lobbyAnimationInterval) {
                clearInterval(gameState.lobbyAnimationInterval);
                gameState.lobbyAnimationInterval = null;
            }
        }
        
        function updateLobbyKnightFrames() {
            document.querySelectorAll('.lobby-knight').forEach(el => {
                const frame = gameState.lobbyAnimationFrame || 1;
                const knightImg = el.querySelector('.knight-image');
                if (knightImg && KNIGHT_FRAMES[frame]) knightImg.src = KNIGHT_FRAMES[frame];
            });
        }
        
        function startLobbyMovement() {
            if (gameState.lobbyMoveInterval) clearInterval(gameState.lobbyMoveInterval);
            gameState.lobbyMoveInterval = setInterval(() => {
                Object.values(gameState.lobbyPlayers).forEach(player => {
                    // Random direction changes
                    if (Math.random() < 0.04) player.direction = Math.random() * Math.PI * 2;
                    if (Math.random() < 0.02) player.direction += Math.PI;
                    
                    let newX = player.x + Math.cos(player.direction) * CONFIG.playerMoveSpeed;
                    let newY = player.y + Math.sin(player.direction) * CONFIG.playerMoveSpeed;
                    
                    // Bounce off screen edges (full lobby area)
                    const margin = 50;
                    if (newX < margin || newX > 1870) {
                        player.direction = Math.PI - player.direction + (Math.random() - 0.5) * 0.5;
                        newX = Math.max(margin, Math.min(1870, newX));
                    }
                    if (newY < 150 || newY > 950) {
                        player.direction = -player.direction + (Math.random() - 0.5) * 0.5;
                        newY = Math.max(150, Math.min(950, newY));
                    }
                    
                    player.x = newX;
                    player.y = newY;
                    
                    const el = document.querySelector(`[data-lobby-username="${player.username}"]`);
                    if (el) {
                        el.style.left = player.x + 'px';
                        el.style.top = player.y + 'px';
                        const img = el.querySelector('.knight-image');
                        if (img) img.style.transform = Math.cos(player.direction) < 0 ? 'scaleX(-1)' : 'scaleX(1)';
                    }
                });
            }, CONFIG.playerMoveInterval);
        }
        
        function lobbyAttack(attackerName, message) {
            const attacker = gameState.lobbyPlayers[attackerName];
            if (!attacker) return;
            
            // Parse target name from "!attack @targetname"
            const targetName = message.substring(9).trim(); // Remove "!attack @"
            const target = Object.values(gameState.lobbyPlayers).find(
                p => p.username.toLowerCase() === targetName.toLowerCase()
            );
            
            if (!target || target.username === attackerName) return;
            
            initAudio();
            playSound('attack');
            
            // Launch arrow from attacker to target
            launchLobbyProjectile(attacker, target);
        }
        
        function launchLobbyProjectile(attacker, target) {
            const projectile = document.createElement('div');
            projectile.className = 'lobby-projectile';
            projectile.style.backgroundImage = `url(${PROJECTILE_IMAGES.bow})`;
            
            const startX = attacker.x + 30;
            const startY = attacker.y + 30;
            const endX = target.x + 30;
            const endY = target.y + 30;
            
            // Calculate angle for arrow rotation
            const dx = endX - startX;
            const dy = endY - startY;
            const angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90;
            projectile.style.transform = `rotate(${angle}deg)`;
            
            projectile.style.left = startX + 'px';
            projectile.style.top = startY + 'px';
            
            elements.lobbyPlayerArea.appendChild(projectile);
            
            const duration = 400;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 2);
                
                // Get current target position (they might have moved)
                const currentTarget = gameState.lobbyPlayers[target.username];
                const currentEndX = currentTarget ? currentTarget.x + 30 : endX;
                const currentEndY = currentTarget ? currentTarget.y + 30 : endY;
                
                const currentX = startX + (currentEndX - startX) * ease;
                const currentY = startY + (currentEndY - startY) * ease;
                
                projectile.style.left = currentX + 'px';
                projectile.style.top = currentY + 'px';
                
                // Update rotation as target moves
                const newDx = currentEndX - currentX;
                const newDy = currentEndY - currentY;
                const newAngle = Math.atan2(newDy, newDx) * (180 / Math.PI) + 90;
                projectile.style.transform = `rotate(${newAngle}deg)`;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    projectile.remove();
                    
                    // Apply hit effect on target
                    lobbyHitEffect(target.username);
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        function lobbyHitEffect(username) {
            const el = document.querySelector(`[data-lobby-username="${username}"]`);
            if (!el) return;
            
            // Add hit class for bounce and flash
            el.classList.add('lobby-hit');
            setTimeout(() => el.classList.remove('lobby-hit'), 400);
        }
        
        function lobbyTaunt(username, message) {
            const player = gameState.lobbyPlayers[username];
            if (!player) return;
            
            // Extract taunt message (after "!taunt ")
            const tauntText = message.substring(7).trim();
            if (tauntText.length === 0 || tauntText.length > 18) return; // Must be 1-18 chars
            
            const el = document.querySelector(`[data-lobby-username="${username}"]`);
            if (!el) return;
            
            // Remove any existing bubble
            const existing = el.querySelector('.lobby-speech-bubble');
            if (existing) existing.remove();
            
            const bubble = document.createElement('div');
            bubble.className = 'lobby-speech-bubble';
            bubble.textContent = tauntText;
            el.appendChild(bubble);
            
            // Remove after animation
            setTimeout(() => bubble.remove(), 2500);
        }

        function getDistanceMultiplier(player) {
            const dist = player.y / CONFIG.playAreaHeight;
            return CONFIG.maxDamageMultiplier - (dist * (CONFIG.maxDamageMultiplier - CONFIG.minDamageMultiplier));
        }

        function playerAttack(username) {
            const player = gameState.players[username];
            if (!player || !player.alive) return;
            if (player.shielded) return; // Can't attack while shielded
            if (Date.now() - player.lastAttack < CONFIG.attackCooldown) {
                const remaining = Math.ceil((CONFIG.attackCooldown - (Date.now() - player.lastAttack)) / 1000);
                addBattleLog(player.username, `attack on cooldown (${remaining}s)`, 'system');
                return;
            }
            player.lastAttack = Date.now();
            
            initAudio();
            
            // Random number of arrows (1-2)
            const arrowCount = 1 + Math.floor(Math.random() * 2);
            const arrowInterval = 500; // 0.5 seconds between arrows
            
            for (let i = 0; i < arrowCount; i++) {
                setTimeout(() => {
                    // Check player is still alive before firing each arrow
                    if (!player.alive || gameState.phase !== 'battle') return;
                    
                    playSound('attack');
                    
                    const el = document.querySelector(`[data-username="${username}"]`);
                    if (el) { 
                        el.classList.add('attacking'); 
                        setTimeout(() => el.classList.remove('attacking'), 250); 
                    }
                    
                    launchPlayerProjectile(player);
                }, i * arrowInterval);
            }
        }

        function launchPlayerProjectile(player) {
            const projectile = document.createElement('div');
            projectile.className = 'player-projectile';
            projectile.style.backgroundImage = `url(${PROJECTILE_IMAGES.bow})`;
            
            const bossCenter = getBossCenter();
            const startX = 80 + player.x + 24;
            const startY = CONFIG.playerAreaTop + player.y + 24;
            
            // Calculate angle to boss for arrow rotation (pointy end toward boss)
            const dx = bossCenter.x - startX;
            const dy = bossCenter.y - startY;
            const angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90; // +90 because arrow points up by default
            projectile.style.transform = `rotate(${angle}deg)`;
            
            projectile.style.left = startX + 'px';
            projectile.style.top = startY + 'px';
            
            elements.projectilesContainer.appendChild(projectile);
            
            const duration = 280;
            const startTime = performance.now();
            
            function animate(currentTime) {
                const progress = Math.min((currentTime - startTime) / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 2);
                
                projectile.style.left = (startX + (bossCenter.x - startX) * ease) + 'px';
                projectile.style.top = (startY + (bossCenter.y - startY) * ease) + 'px';
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    projectile.remove();
                    
                    const impact = document.createElement('div');
                    impact.className = 'impact player-impact';
                    impact.style.left = (bossCenter.x - 15) + 'px';
                    impact.style.top = bossCenter.y + 'px';
                    elements.projectilesContainer.appendChild(impact);
                    setTimeout(() => impact.remove(), 300);
                    
                    playSound('playerHit');
                    
                    const mult = getDistanceMultiplier(player);
                    let dmg = Math.floor(CONFIG.bowDamage * mult);
                    const crit = Math.random() < CONFIG.bowCritChance;
                    if (crit) dmg *= 2;
                    
                    // Apply taunt boost (50% extra damage)
                    if (player.tauntBoost) {
                        dmg = Math.floor(dmg * 1.5);
                        player.tauntBoost = false;
                    }
                    
                    gameState.boss.health = Math.max(0, gameState.boss.health - dmg);
                    player.damage += dmg;
                    gameState.totalDamage += dmg;
                    addBattleLog(player.username, `dealt ${dmg}${crit ? ' CRIT!' : ''} damage`, 'attack');
                    
                    elements.bossSprite.classList.add('damaged');
                    setTimeout(() => elements.bossSprite.classList.remove('damaged'), 150);
                    
                    createFloatingText(elements.bossSprite.getBoundingClientRect(), `-${dmg}${crit ? '!' : ''}`, crit ? 'crit' : 'damage');
                    updateBossHealth();
                    updateUI();
                    
                    // Check victory
                    if (gameState.boss.health <= 0) {
                        triggerBossDeath();
                    }
                }
            }
            
            requestAnimationFrame(animate);
        }

        function playerHeal(username, target) {
            const player = gameState.players[username];
            if (!player || !player.alive) return;
            if (player.shielded) return; // Can't heal while shielded
            if (Date.now() - player.lastHeal < CONFIG.healCooldown) {
                const remaining = Math.ceil((CONFIG.healCooldown - (Date.now() - player.lastHeal)) / 1000);
                addBattleLog(player.username, `heal on cooldown (${remaining}s)`, 'system');
                return;
            }
            player.lastHeal = Date.now();
            
            initAudio();
            playSound('heal');
            
            let healTarget = player;
            if (target && target.startsWith('@')) {
                const found = Object.values(gameState.players).find(p => p.username.toLowerCase() === target.substring(1).toLowerCase());
                if (found && found.alive) healTarget = found;
            }
            
            const amt = Math.min(CONFIG.healAmount, healTarget.maxHealth - healTarget.health);
            healTarget.health += amt;
            player.healing += amt;
            if (healTarget === player) {
                addBattleLog(player.username, `healed for ${amt}`, 'heal');
            } else {
                addBattleLog(player.username, `healed ${healTarget.username} for ${amt}`, 'heal');
            }
            
            const el = document.querySelector(`[data-username="${healTarget.username}"]`);
            if (el) {
                el.classList.add('healing');
                setTimeout(() => el.classList.remove('healing'), 500);
                createFloatingText(el.getBoundingClientRect(), `+${amt}`, 'heal');
            }
            
            updatePlayerSprite(healTarget.username);
        }

        function playerShield(username) {
            const player = gameState.players[username];
            if (!player || !player.alive) return;
            if (player.shielded) return; // Already shielded
            if (Date.now() - player.lastShield < 15000) {
                const remaining = Math.ceil((15000 - (Date.now() - player.lastShield)) / 1000);
                addBattleLog(player.username, `shield on cooldown (${remaining}s)`, 'system');
                return;
            }
            
            player.shielded = true;
            player.lastShield = Date.now();
            
            const el = document.querySelector(`[data-username="${username}"]`);
            if (el) {
                el.classList.add('shielded');
            }
            
            // Shield lasts 5 seconds
            setTimeout(() => {
                player.shielded = false;
                if (el) el.classList.remove('shielded');
            }, 5000);
        }
        
        function playerTaunt(username, message) {
            const player = gameState.players[username];
            if (!player || !player.alive) return;
            if (player.shielded) return; // Can't taunt while shielded
            if (Date.now() - (player.lastTaunt || 0) < 5000) return; // 5 second cooldown
            player.lastTaunt = Date.now();
            
            // Extract taunt message (after "!taunt ")
            const tauntText = message.substring(7).trim();
            if (tauntText.length === 0 || tauntText.length > 18) return; // Must be 1-18 chars
            
            // Give taunt boost for next attack
            player.tauntBoost = true;
            
            // Show speech bubble
            const el = document.querySelector(`[data-username="${username}"]`);
            if (el) {
                // Remove any existing bubble
                const existing = el.querySelector('.speech-bubble');
                if (existing) existing.remove();
                
                const bubble = document.createElement('div');
                bubble.className = 'speech-bubble';
                bubble.textContent = tauntText;
                el.appendChild(bubble);
                
                // Remove bubble after 3 seconds
                setTimeout(() => bubble.remove(), 3000);
            }
        }
        
        function playerRevive(username, target) {
            const player = gameState.players[username];
            if (!player) return;
            
            // Only dead players can revive
            if (player.alive) {
                addBattleLog(player.username, 'you must be defeated to revive others', 'system');
                return;
            }
            
            // One revive per game
            if (player.hasRevived) {
                addBattleLog(player.username, 'already used revive this game', 'system');
                return;
            }
            
            // Must target someone
            if (!target || !target.startsWith('@')) {
                addBattleLog(player.username, 'use !revive @playername', 'system');
                return;
            }
            
            const targetName = target.substring(1).toLowerCase();
            const targetPlayer = Object.values(gameState.players).find(
                p => p.username.toLowerCase() === targetName
            );
            
            // Can't revive yourself
            if (targetPlayer && targetPlayer.username === username) {
                addBattleLog(player.username, 'cannot revive yourself', 'system');
                return;
            }
            
            if (!targetPlayer) {
                addBattleLog(player.username, 'player not found', 'system');
                return;
            }
            
            if (targetPlayer.alive) {
                addBattleLog(player.username, `${targetPlayer.username} is still alive`, 'system');
                return;
            }
            
            // Already being revived by someone else
            if (targetPlayer.reviving) {
                addBattleLog(player.username, `${targetPlayer.username} is already being revived`, 'system');
                return;
            }
            
            // Mark revive used immediately
            player.hasRevived = true;
            targetPlayer.reviving = true;
            
            initAudio();
            addBattleLog(player.username, `is reviving ${targetPlayer.username}...`, 'heal');
            
            // Show revive bar on the target's death marker
            const targetEl = document.querySelector(`[data-username="${targetPlayer.username}"]`);
            if (targetEl) {
                // Remove any existing revive bar
                const existing = targetEl.querySelector('.revive-bar-container');
                if (existing) existing.remove();
                
                const barContainer = document.createElement('div');
                barContainer.className = 'revive-bar-container';
                barContainer.innerHTML = `
                    <div class="revive-label">REVIVING...</div>
                    <div class="revive-bar">
                        <div class="revive-bar-fill" id="revive-fill-${targetPlayer.username}"></div>
                    </div>
                `;
                targetEl.appendChild(barContainer);
                
                // Animate the bar over 15 seconds
                const reviveDuration = 15000;
                const reviveStart = Date.now();
                const fillEl = barContainer.querySelector('.revive-bar-fill');
                
                function updateReviveBar() {
                    if (gameState.phase !== 'battle') {
                        barContainer.remove();
                        targetPlayer.reviving = false;
                        return;
                    }
                    
                    const elapsed = Date.now() - reviveStart;
                    const progress = Math.min(elapsed / reviveDuration, 1);
                    fillEl.style.width = (progress * 100) + '%';
                    
                    if (progress < 1) {
                        requestAnimationFrame(updateReviveBar);
                    } else {
                        // Revive complete
                        barContainer.remove();
                        targetPlayer.reviving = false;
                        completeRevive(targetPlayer);
                    }
                }
                
                requestAnimationFrame(updateReviveBar);
            }
        }
        
        function completeRevive(player) {
            player.alive = true;
            player.revived = true;
            player.health = Math.floor(player.maxHealth * 0.5); // Revive at 50% HP
            
            initAudio();
            playSound('revive');
            
            addBattleLog(player.username, 'has been revived!', 'heal');
            
            const el = document.querySelector(`[data-username="${player.username}"]`);
            if (el) {
                // Remove dead class, add revived and flash
                el.classList.remove('dead');
                el.classList.add('revived', 'revive-flash', 'walking');
                setTimeout(() => el.classList.remove('revive-flash'), 600);
                
                // Swap to revived sprite
                const knightImg = el.querySelector('.knight-image');
                if (knightImg) {
                    const frame = gameState.animationFrame || 1;
                    knightImg.src = REVIVED_FRAMES[frame] || REVIVED_FRAMES[1];
                }
                
                // Show health bar again
                updatePlayerSprite(player.username);
            }
            
            updateUI();
        }
        
        function resetBoss() {
            gameState.boss = { health: CONFIG.bossHealth, maxHealth: CONFIG.bossHealth };
            updateBossHealth();
            elements.bossPhase.textContent = 'GROUND SLAM';
        }

        function bossAttack() {
            if (gameState.phase !== 'battle') return;
            
            // Don't start a new attack if rage attack is in progress
            if (gameState.isRageAttack) return;
            
            const alive = Object.values(gameState.players).filter(p => p.alive);
            if (alive.length === 0) { endGame('defeat'); return; }
            
            initAudio();
            
            // Increment slam counter
            gameState.slamCount++;
            
            // Check if this is a rage attack
            const isRageAttack = gameState.slamCount >= gameState.nextRageSlam;
            gameState.isRageAttack = isRageAttack;
            
            // Set attack parameters based on rage status
            const minProj = isRageAttack ? CONFIG.rageProjectilesMin : CONFIG.projectilesMin;
            const maxProj = isRageAttack ? CONFIG.rageProjectilesMax : CONFIG.projectilesMax;
            const hitChance = isRageAttack ? CONFIG.rageHitChance : CONFIG.hitChance;
            
            // Side rain on every other normal attack
            const shouldSideRain = gameState.slamCount % 2 === 0;
            
            // Randomized number of projectiles
            const numProjectiles = minProj + Math.floor(Math.random() * (maxProj - minProj + 1));
            
            if (isRageAttack) {
                // RAGE ATTACK - 3 consecutive slams with 1 second roar warning!
                gameState.isRageAttack = true; // Set flag immediately to prevent overlapping attacks
                elements.game.classList.add('rage-mode');
                elements.rageOverlay.classList.add('active');
                elements.bossPhase.textContent = 'RAGE ATTACK!';
                
                addBattleLog('BATSY', 'is ENRAGED!', 'boss');
                
                // === ROAR WARNING PHASE (1 second) ===
                // Batsy enters pre-slam pose and roars
                setBossFrame('preslam');
                playSound('roar');
                
                // Screen shake during roar
                elements.game.classList.add('shaking');
                setTimeout(() => elements.game.classList.remove('shaking'), 800);
                
                // Hide the "RAGE ATTACK!" overlay after 500ms (50% shorter display)
                setTimeout(() => {
                    elements.rageOverlay.classList.remove('active');
                }, 500);
                
                // Roar duration before slams begin
                const roarDuration = 1000;
                
                // 3 consecutive rage slams (after roar)
                const slamInterval = 600; // Time between each slam
                
                for (let slam = 0; slam < 3; slam++) {
                    setTimeout(() => {
                        if (gameState.phase !== 'battle') return;
                        
                        // Slam animation
                        setBossFrame('preslam');
                        elements.bossSprite.classList.add('frenzied');
                        
                        setTimeout(() => {
                            if (gameState.phase !== 'battle') return;
                            setBossFrame('slam');
                            playSound('slam');
                            
                            // Screen shake on each slam
                            elements.game.classList.add('shaking');
                            setTimeout(() => elements.game.classList.remove('shaking'), 200);
                            
                            // Launch rage projectiles
                            const projCount = CONFIG.rageProjectilesMin + Math.floor(Math.random() * (CONFIG.rageProjectilesMax - CONFIG.rageProjectilesMin + 1));
                            for (let i = 0; i < projCount; i++) {
                                const delay = i * (30 + Math.random() * 50);
                                setTimeout(() => {
                                    if (gameState.phase === 'battle') {
                                        launchBossProjectile(hitChance, true);
                                    }
                                }, delay);
                            }
                            
                            // Side rain on each slam
                            const sideRainCount = 2 + Math.floor(Math.random() * 2);
                            for (let i = 0; i < sideRainCount; i++) {
                                const delay = i * (60 + Math.random() * 40);
                                setTimeout(() => {
                                    if (gameState.phase === 'battle') {
                                        launchSideRainProjectile('left', hitChance, true);
                                        launchSideRainProjectile('right', hitChance, true);
                                    }
                                }, delay);
                            }
                        }, 150);
                        
                        // Return to static briefly between slams
                        setTimeout(() => {
                            setBossFrame('static');
                            elements.bossSprite.classList.remove('frenzied');
                        }, 400);
                        
                    }, roarDuration + (slam * slamInterval));
                }
                
                // End rage mode after roar + all 3 slams
                setTimeout(() => {
                    setBossFrame('static');
                    elements.bossSprite.classList.remove('frenzied');
                    elements.game.classList.remove('rage-mode');
                    elements.rageOverlay.classList.remove('active');
                    elements.bossPhase.textContent = 'GROUND SLAM';
                    
                    // Reset slam counter and calculate next rage
                    gameState.slamCount = 0;
                    gameState.nextRageSlam = calculateNextRageSlam();
                    gameState.isRageAttack = false;
                    
                    addBattleLog('BATSY', 'calms down...', 'boss');
                }, roarDuration + (3 * slamInterval) + 200);
                
            } else {
                // Normal slam attack
                setBossFrame('preslam');
                elements.bossSprite.classList.add('slamming');
                
                setTimeout(() => {
                    setBossFrame('slam');
                    playSound('slam');
                    
                    for (let i = 0; i < numProjectiles; i++) {
                        const delay = i * (50 + Math.random() * 100);
                        setTimeout(() => {
                            if (gameState.phase === 'battle') {
                                launchBossProjectile(hitChance, false);
                            }
                        }, delay);
                    }
                    
                    // Side rain on every other attack
                    if (shouldSideRain && gameState.phase === 'battle') {
                        const sideRainCount = 3 + Math.floor(Math.random() * 3);
                        for (let i = 0; i < sideRainCount; i++) {
                            const delay = i * (150 + Math.random() * 100);
                            setTimeout(() => {
                                if (gameState.phase === 'battle') {
                                    launchSideRainProjectile('left', hitChance, false);
                                    launchSideRainProjectile('right', hitChance, false);
                                }
                            }, delay);
                        }
                    }
                }, 300);
                
                setTimeout(() => {
                    setBossFrame('static');
                    elements.bossSprite.classList.remove('slamming');
                }, 800);
            }
        }

        function applyProjectileDamage(player, projectileData) {
            const px = CONFIG.playerAreaOffsetX + player.x;
            const py = CONFIG.playerAreaOffsetY + player.y;
            
            projectileData.hasHit = true;
            projectileData.element.remove();
            
            const impact = document.createElement('div');
            impact.className = 'impact' + (projectileData.isRage ? ' phase2' : '');
            impact.style.left = (projectileData.x - 20) + 'px';
            impact.style.top = projectileData.y + 'px';
            elements.projectilesContainer.appendChild(impact);
            setTimeout(() => impact.remove(), 400);
            
            const mult = getDistanceMultiplier(player);
            let dmg = Math.floor(CONFIG.bossBaseDamage * mult * (0.7 + Math.random() * 0.6));
            if (projectileData.isRage) dmg = Math.floor(dmg * CONFIG.rageDamageMultiplier);
            
            player.health -= dmg;
            playSound('hit');
            const label = projectileData.isSideRain ? `took ${dmg} damage (side rain)` : `took ${dmg} damage`;
            addBattleLog(player.username, label, 'hit');
            
            const el = document.querySelector(`[data-username="${player.username}"]`);
            if (el) {
                el.classList.add('damaged');
                setTimeout(() => el.classList.remove('damaged'), 250);
            }
            
            updatePlayerSprite(player.username);
            createFloatingText({ left: px, top: py, width: CONFIG.playerHitboxWidth, height: CONFIG.playerHitboxHeight }, `-${dmg}`, 'damage');
            
            if (player.health <= 0) {
                player.health = 0;
                player.alive = false;
                playSound('death');
                const deathMarker = document.createElement('div');
                deathMarker.className = 'impact death-marker';
                deathMarker.style.left = (px - 30) + 'px';
                deathMarker.style.top = (py - 30) + 'px';
                elements.projectilesContainer.appendChild(deathMarker);
                setTimeout(() => deathMarker.remove(), 600);
                
                createDeathEffect(px, py);
                addBattleLog(player.username, 'defeated!', 'death');
                updatePlayerSprite(player.username);
            }
            
            updateUI();
            if (Object.values(gameState.players).filter(p => p.alive).length === 0) endGame('defeat');
            
            const idx = gameState.activeProjectiles.indexOf(projectileData);
            if (idx > -1) gameState.activeProjectiles.splice(idx, 1);
        }

        function launchBossProjectile(hitChance, isRage) {
            const projectile = document.createElement('div');
            projectile.className = 'boss-projectile' + (isRage ? ' rage' : '');
            
            // Randomly choose between large and small projectile images
            const projImage = Math.random() < 0.5 ? PROJECTILE_IMAGES.bossLarge : PROJECTILE_IMAGES.bossSmall;
            projectile.style.backgroundImage = `url(${projImage})`;
            
            const bossCenter = getBossCenter();
            
            // 175 degree arc: focused downward spread to hit edge players
            // Angle range: -87.5 to +87.5 degrees from straight down (90 degrees)
            // This means projectiles can go from nearly horizontal-left to nearly horizontal-right
            const spreadAngle = (Math.random() - 0.5) * Math.PI * 0.97; // ~175 degrees spread
            const baseAngle = Math.PI / 2; // 90 degrees = straight down
            const angle = baseAngle + spreadAngle;
            
            // Randomized speed
            const baseSpeed = isRage ? 6.5 : 5;
            const speed = baseSpeed + Math.random() * 3.5;
            
            // Calculate velocity - proper trigonometry for full spread
            // At spreadAngle = 0: goes straight down
            // At spreadAngle = -87.5°: goes mostly left with slight downward
            // At spreadAngle = +87.5°: goes mostly right with slight downward
            let vx = Math.cos(angle) * speed;
            let vy = Math.sin(angle) * speed * 0.6; // Slightly reduce vertical to give more horizontal travel time
            
            // Wider starting position spread from boss sprite edges
            const spreadX = (Math.random() - 0.5) * 250;
            let x = bossCenter.x + spreadX;
            let y = bossCenter.y + 40;
            
            projectile.style.left = x + 'px';
            projectile.style.top = y + 'px';
            
            elements.projectilesContainer.appendChild(projectile);
            
            // Determine if this projectile can hit (with randomized chance)
            const actualHitChance = hitChance + (Math.random() - 0.5) * 0.2; // 40-60% variance
            const willHit = Math.random() < actualHitChance;
            
            const projectileData = { element: projectile, x, y, vx, vy, willHit, hasHit: false, isRage };
            gameState.activeProjectiles.push(projectileData);
            
            function animate() {
                if (projectileData.hasHit || !projectile.parentNode) return;
                
                projectileData.x += projectileData.vx;
                projectileData.y += projectileData.vy;
                projectileData.vy += 0.18; // Gravity
                
                // Add slight wobble for phase 2
                if (projectileData.isRage) {
                    projectileData.x += Math.sin(projectileData.y * 0.05) * 0.5;
                }
                
                projectile.style.left = projectileData.x + 'px';
                projectile.style.top = projectileData.y + 'px';
                projectile.style.transform = `rotate(${projectileData.vy * 8}deg)`;
                
                // Hitbox collision
                if (projectileData.willHit) {
                    const alive = Object.values(gameState.players).filter(p => p.alive);
                    for (const player of alive) {
                        if (player.shielded) continue;
                        
                        const px = CONFIG.playerAreaOffsetX + player.x;
                        const py = CONFIG.playerAreaOffsetY + player.y;
                        const projSize = projectileData.isRage ? CONFIG.rageProjectileSize : CONFIG.projectileSize;
                        
                        if (projectileData.x > px - projSize &&
                            projectileData.x < px + CONFIG.playerHitboxWidth &&
                            projectileData.y > py - projSize &&
                            projectileData.y < py + CONFIG.playerHitboxHeight) {
                            
                            applyProjectileDamage(player, projectileData);
                            return;
                        }
                    }
                }
                
                // Off screen
                if (projectileData.y > 1100 || projectileData.x < -50 || projectileData.x > 1970) {
                    projectile.remove();
                    const idx = gameState.activeProjectiles.indexOf(projectileData);
                    if (idx > -1) gameState.activeProjectiles.splice(idx, 1);
                    return;
                }
                
                requestAnimationFrame(animate);
            }
            
            requestAnimationFrame(animate);
        }

        // Side rain projectiles - fall from top on left/right 25% of screen
        function launchSideRainProjectile(side, hitChance, isRage) {
            const projectile = document.createElement('div');
            projectile.className = 'rain-projectile' + (isRage ? ' rage' : '');
            
            // Randomly choose between large and small
            const rockImage = Math.random() < 0.5 
            ? FALL_PROJECTILE_IMAGES.rockSlideLarge 
            : FALL_PROJECTILE_IMAGES.rockSlideSmall;

            projectile.style.backgroundImage = `url(${rockImage})`;
            
            // Calculate x position based on side (left or right 25% of play area)
            // Play area starts at x=80 and is CONFIG.playAreaWidth wide
            const playAreaLeft = CONFIG.playerAreaOffsetX;
            const playAreaRight = playAreaLeft + CONFIG.playAreaWidth;
            const quarterWidth = CONFIG.playAreaWidth * 0.25;
            
            let x;
            if (side === 'left') {
                // Left 25%: from playAreaLeft to playAreaLeft + quarterWidth
                x = playAreaLeft + Math.random() * quarterWidth;
            } else {
                // Right 25%: from playAreaRight - quarterWidth to playAreaRight
                x = (playAreaRight - quarterWidth) + Math.random() * quarterWidth;
            }
            
            // Start above the screen
            let y = -30;
            
            // Fall straight down with some speed variation (20% faster)
            const baseSpeed = isRage ? 6 : 4.8;
            const vy = baseSpeed + Math.random() * 2.4;
            const vx = (Math.random() - 0.5) * 0.5; // Very slight horizontal drift
            
            projectile.style.left = x + 'px';
            projectile.style.top = y + 'px';
            
            elements.projectilesContainer.appendChild(projectile);
            
            const actualHitChance = hitChance + (Math.random() - 0.5) * 0.2;
            const willHit = Math.random() < actualHitChance;
            
            const projectileData = { element: projectile, x, y, vx, vy, willHit, hasHit: false, isRage, isSideRain: true };
            gameState.activeProjectiles.push(projectileData);
            
            function animate() {
                if (projectileData.hasHit || !projectile.parentNode) return;
                
                projectileData.x += projectileData.vx;
                projectileData.y += projectileData.vy;
                // No gravity for side rain - constant fall speed
                
                projectile.style.left = projectileData.x + 'px';
                projectile.style.top = projectileData.y + 'px';
                
                // Check collision with players
                if (projectileData.willHit) {
                    const alivePlayers = Object.values(gameState.players).filter(p => p.alive);
                    for (const player of alivePlayers) {
                        if (player.shielded) continue;
                        
                        const px = CONFIG.playerAreaOffsetX + player.x;
                        const py = CONFIG.playerAreaOffsetY + player.y;
                        const projSize = projectileData.isRage ? CONFIG.rageProjectileSize : CONFIG.projectileSize;
                        
                        if (projectileData.x > px - projSize &&
                            projectileData.x < px + CONFIG.playerHitboxWidth &&
                            projectileData.y > py - projSize &&
                            projectileData.y < py + CONFIG.playerHitboxHeight) {
                            
                            applyProjectileDamage(player, projectileData);
                            return;
                        }
                    }
                }
                
                // Off screen (bottom)
                if (projectileData.y > 1100) {
                    projectile.remove();
                    const idx = gameState.activeProjectiles.indexOf(projectileData);
                    if (idx > -1) gameState.activeProjectiles.splice(idx, 1);
                    return;
                }
                
                requestAnimationFrame(animate);
            }
            
            requestAnimationFrame(animate);
        }

        function updateUI() {
            elements.playerCount.textContent = `${Object.keys(gameState.players).length} / ${CONFIG.maxPlayers}`;
            elements.aliveCount.textContent = Object.values(gameState.players).filter(p => p.alive).length;
            elements.totalDamage.textContent = gameState.totalDamage.toLocaleString();
        }

        function updateBossHealth() {
            const pct = (gameState.boss.health / gameState.boss.maxHealth) * 100;
            elements.bossHealthFill.style.width = `${pct}%`;
            elements.bossHealthText.textContent = `${gameState.boss.health} / ${gameState.boss.maxHealth}`;
        }

        function updateGameTimer() {
            if (!gameState.gameStartTime) return;
            const s = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            elements.gameTimer.textContent = `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
        }

        function renderPlayers() {
            elements.playerArea.innerHTML = '';
            Object.values(gameState.players).forEach(player => {
                const container = document.createElement('div');
                container.className = `player-sprite-container ${player.alive ? '' : 'dead'}`;
                container.dataset.username = player.username;
                container.style.left = player.x + 'px';
                container.style.top = player.y + 'px';
                
                const healthPct = (player.health / player.maxHealth) * 100;
                const healthClass = healthPct <= 30 ? 'low' : healthPct <= 60 ? 'medium' : '';
                
                const frame = gameState.animationFrame || 1;
                const knightSrc = KNIGHT_FRAMES[frame] || KNIGHT_FRAMES[1];
                
                container.innerHTML = `
                    <img class="knight-image" src="${knightSrc}" alt="Knight">
                    <div class="player-info">
                        <div class="player-name">${player.username}</div>
                        <div class="player-health-bar">
                            <div class="player-health-fill ${healthClass}" style="width:${healthPct}%"></div>
                        </div>
                    </div>
                `;
                
                elements.playerArea.appendChild(container);
            });
        }

        function updatePlayerSprite(username) {
            const player = gameState.players[username];
            if (!player) return;
            
            const el = document.querySelector(`[data-username="${username}"]`);
            if (!el) return;
            
            // Build class list
            let classes = 'player-sprite-container';
            if (!player.alive) classes += ' dead';
            else if (gameState.phase === 'battle') classes += ' walking';
            if (player.revived && player.alive) classes += ' revived';
            el.className = classes;
            
            const healthPct = (player.health / player.maxHealth) * 100;
            const healthFill = el.querySelector('.player-health-fill');
            if (healthFill) {
                healthFill.style.width = healthPct + '%';
                const healthClass = healthPct <= 30 ? 'low' : healthPct <= 60 ? 'medium' : '';
                healthFill.className = `player-health-fill ${healthClass}`;
            }
            
            // Update knight frame — use revived frames if player was revived
            const knightImg = el.querySelector('.knight-image');
            if (knightImg) {
                const frame = gameState.animationFrame || 1;
                if (player.revived && player.alive) {
                    knightImg.src = REVIVED_FRAMES[frame] || REVIVED_FRAMES[1];
                } else {
                    knightImg.src = KNIGHT_FRAMES[frame] || KNIGHT_FRAMES[1];
                }
            }
        }

        function createFloatingText(rect, text, type) {
            const el = document.createElement('div');
            el.className = `floating-text ${type}`;
            el.textContent = text;
            el.style.left = `${rect.left + rect.width/2}px`;
            el.style.top = `${rect.top}px`;
            elements.floatingTextContainer.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function createDeathEffect(x, y) {
            // Main death effect
            const deathEl = document.createElement('div');
            deathEl.className = 'death-effect';
            deathEl.style.left = (x + 24) + 'px';
            deathEl.style.top = (y + 24) + 'px';
            elements.projectilesContainer.appendChild(deathEl);
            setTimeout(() => deathEl.remove(), 800);
            
            // Particle burst
            const numParticles = 8;
            for (let i = 0; i < numParticles; i++) {
                const particle = document.createElement('div');
                particle.className = 'death-particle';
                particle.style.left = (x + 24) + 'px';
                particle.style.top = (y + 24) + 'px';
                
                const angle = (i / numParticles) * Math.PI * 2;
                const speed = 3 + Math.random() * 3;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                elements.projectilesContainer.appendChild(particle);
                
                let px = x + 24, py = y + 24;
                let life = 1;
                
                function animateParticle() {
                    px += vx;
                    py += vy + 0.5; // slight gravity
                    life -= 0.03;
                    
                    particle.style.left = px + 'px';
                    particle.style.top = py + 'px';
                    particle.style.opacity = life;
                    particle.style.transform = `scale(${life})`;
                    
                    if (life > 0) {
                        requestAnimationFrame(animateParticle);
                    } else {
                        particle.remove();
                    }
                }
                
                requestAnimationFrame(animateParticle);
            }
        }

        function addBattleLog(name, action, type) {
            const entry = document.createElement('div');
            entry.className = 'battle-log-entry';
            let color = 'var(--rose)';
            if (type === 'boss') color = 'var(--rage-orange)';
            else if (type === 'system') color = 'var(--lavender)';
            else if (type === 'attack') color = 'var(--gold)';
            else if (type === 'heal') color = 'var(--health-green)';
            else if (type === 'hit') color = 'var(--health-red)';
            else if (type === 'death') color = '#888';
            entry.innerHTML = `<span style="color:${color}">${name}</span> ${action}`;
            elements.battleLog.appendChild(entry);
            elements.battleLog.scrollTop = elements.battleLog.scrollHeight;
            while (elements.battleLog.children.length > 51) elements.battleLog.children[1].remove();
        }

        function showVictoryScreen() {
            playSound('victory');
            const players = Object.values(gameState.players);
            const mvp = players.reduce((best, p) => (p.damage + p.healing) > (best.damage + best.healing) ? p : best, players[0]);
            
            document.getElementById('mvp-name').textContent = mvp.username;
            document.getElementById('mvp-damage').textContent = mvp.damage.toLocaleString();
            document.getElementById('mvp-healing').textContent = mvp.healing.toLocaleString();
            
            const grid = document.getElementById('victory-stats');
            grid.innerHTML = '';
            players.sort((a,b) => (b.damage + b.healing) - (a.damage + a.healing)).slice(0, 10).forEach(p => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `<div class="stat-card-name">${p.username}</div><div class="stat-card-damage">⚔️ ${p.damage}</div><div class="stat-card-healing">❤️ ${p.healing}</div>`;
                grid.appendChild(card);
            });
            
            elements.victoryScreen.classList.add('active');
        }

        function showDefeatScreen() {
            playSound('defeat');
            const players = Object.values(gameState.players);
            const mvp = players.reduce((best, p) => (p.damage + p.healing) > (best.damage + best.healing) ? p : best, players[0]);
            
            document.getElementById('defeat-mvp-name').textContent = mvp ? mvp.username : 'No one';
            document.getElementById('defeat-boss-hp').textContent = gameState.boss.health;
            document.getElementById('defeat-team-damage').textContent = gameState.totalDamage.toLocaleString();
            
            elements.defeatScreen.classList.add('active');
        }

        // Keyboard controls
        /*document.addEventListener('keydown', e => {
            if (e.key === 'Enter') startLobby();
            if (e.key === '1') handleCommand('Player1', '!play');
            if (e.key === '2') handleCommand('Player2', '!play');
            if (e.key === '3') handleCommand('Player3', '!play');
            if (e.key === '4') handleCommand('Player4', '!play');
            if (e.key === '5') handleCommand('Player5', '!play');
            // In lobby: attack other players. In battle: attack boss
            if (e.key === 'a') handleCommand('Player1', gameState.phase === 'lobby' ? '!attack @Player2' : '!attack');
            if (e.key === 's') handleCommand('Player2', gameState.phase === 'lobby' ? '!attack @Player1' : '!attack');
            if (e.key === 'd') handleCommand('Player3', gameState.phase === 'lobby' ? '!attack @Player1' : '!attack');
            if (e.key === 'f') handleCommand('Player4', gameState.phase === 'lobby' ? '!attack @Player2' : '!attack');
            if (e.key === 'g') handleCommand('Player5', gameState.phase === 'lobby' ? '!attack @Player3' : '!attack');
            if (e.key === 'h') handleCommand('Player5', '!heal');
            if (e.key === 'r') handleCommand('Player5', '!shield');
            if (e.key === 't') handleCommand('Player1', '!taunt You smell bad!');
            if (e.key === 'v') handleCommand('Player2', '!revive @Player1');
            if (e.key === 'm') handleCommand('Player4', '!revive @Player3');
        });

        console.log('GeoRose Boss Battle v2.0 - Batsy The Beast');
        console.log('ENTER=start, 1-5=join, A/S/D/F/G=attack (lobby: shoots other players), H=heal, R=shield, T=taunt, V=P2 revives P1');*/
    </script>
</body>
</html>
